<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tutorials | Abner Araujo]]></title>
  <link href="http://abner-math.github.io/blog/categories/tutorials/atom.xml" rel="self"/>
  <link href="http://abner-math.github.io/"/>
  <updated>2023-02-11T16:21:31+01:00</updated>
  <id>http://abner-math.github.io/</id>
  <author>
    <name><![CDATA[Abner Araujo]]></name>
    <email><![CDATA[abner.math.c@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Parsing a Hand-drawn Hash Game]]></title>
    <link href="http://abner-math.github.io/blog/2017/06/10/intepreting-a-hand-drawn-hash-game/"/>
    <updated>2017-06-10T17:11:40-03:00</updated>
    <id>http://abner-math.github.io/blog/2017/06/10/intepreting-a-hand-drawn-hash-game</id>
    <content type="html"><![CDATA[<p>In this tutorial I will show you how to parse a hand-drawn hash game with Computer Vision techniques to determine who&rsquo;s the winner (if any). See the example below:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/XHP72q16iU8" frameborder="0" allowfullscreen></iframe>




<!-- more --> 


<p>For this tutorial we are going to use <a href="http://www.opencv.org/">OpenCV 3.2</a>.</p>

<p>Basically, in order to perform what we intend, we need first to detect where are the &lsquo;x&rsquo; and the &lsquo;o&rsquo;, and later check if they are aligned in such way that indicates a win (aligned on horizontal, vertical or diagonal).</p>

<p>Check the image below:</p>

<p style="text-align:center;"><img src="/images/posts/hash1.png" alt="" /></p>

<p>This is the kind of image we want to deal with. In order to detect each element of that image, we need to segment them. We can do that easily with the OpenCV <code>connectedComponents</code> function. What it does is very simple: For each white pixel of a binary image it associates a label indicating to which group (or connected component) the pixel belongs to. A connected component is a set of white pixels where each pixel is a neighbor of some other white pixel within the same component.</p>

<p>For the image above, it would output three connected components: the hash, the &lsquo;x&rsquo; symbol and the &lsquo;o&rsquo; symbol. Once we have all them three apart, the detection process becomes much easier.</p>

<pre><code class="c++ hash.cpp">#include &lt;vector&gt;
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;

cv::Mat gImg;

std::vector&lt;std::pair&lt;cv::Mat, cv::Rect&gt; &gt; getConnectedComponents()
{
    cv::Mat labels(gImg.rows, gImg.cols, CV_32S);
    cv::connectedComponents(gImg, labels);
    int *label = (int*)labels.data;

    std::map&lt;int, std::vector&lt;cv::Point2i&gt; &gt; components;
    for (int y = 0; y &lt; labels.rows; y++)
    {
        for (int x = 0; x &lt; labels.cols; x++)
        {
            if (*label &gt; 0) // not background
            {
                components[*label].push_back(cv::Point2i(x, y));
            }
            ++label;
        }
    }

    std::vector&lt;std::pair&lt;cv::Mat, cv::Rect&gt; &gt; connectedComponents;
    std::vector&lt;cv::Mat&gt; imgs;
    std::vector&lt;cv::Rect&gt; rects;
    for (auto it = components.begin(); it != components.end(); ++it)
    {
        cv::Rect boundingRect;
        cv::Mat img = getComponentImg(it-&gt;second, boundingRect);
        connectedComponents.push_back(std::make_pair(img, boundingRect));
    }
    return connectedComponents;
}

int main()
{
    gImg = cv::imread("hash1.png", 0);
}
</code></pre>

<p>Ok! In order to call the <code>connectedComponents</code> function, we need to pass a image of same dimension of the input image. It will store the label associated to each pixel. Then it iterates over each pixel of the label image and saves the position in a map that associates a label to a vector of positions. After that, we want to get bounding rect and a image containing only the pixels of a determined component. For that I&rsquo;m calling the <code>getComponentImg</code> function. Let&rsquo;s see how it&rsquo;s implemented:</p>

<pre><code class="c++ hash.cpp">cv::Mat getComponentImg(const std::vector&lt;cv::Point2i&gt; &amp;pixels, cv::Rect &amp;boundingRect)
{
    int minX = INT_MAX, maxX = INT_MIN, minY = INT_MAX, maxY = INT_MIN;
    for (size_t i = 0; i &lt; pixels.size(); i++)
    {
        cv::Point2i pixel = pixels[i];
        if (pixel.x &lt; minX) minX = pixel.x;
        if (pixel.x &gt; maxX) maxX = pixel.x;
        if (pixel.y &lt; minY) minY = pixel.y;
        if (pixel.y &gt; maxY) maxY = pixel.y;
    }
    boundingRect = cv::Rect(minX, minY, maxX - minX + 20, maxY - minY + 20);
    cv::Mat img = cv::Mat::zeros(boundingRect.height, boundingRect.width, CV_8U);
    for (size_t i = 0; i &lt; pixels.size(); i++)
    {
        cv::Point2i pixel = pixels[i] - boundingRect.tl() + cv::Point2i(10, 10);
        img.at&lt;uchar&gt;(pixel.y, pixel.x) = static_cast&lt;uchar&gt;(255);
    }
    return img;
}
</code></pre>

<p>Very straight-forward, since we already have a list containing all the positions of the elements within the connected component. All we need to that is get the min and dimensions of those pixels, then calculate a bounding rect, creating a image of the dimension of the bounding rect, iterate over each position and set it in the image we just created.</p>

<p>Ok!!! Now we have each element separated, as we can see below:</p>

<p style="text-align:center;"><img src="/images/posts/hash2.png" alt="" /></p>

<p style="text-align:center;"><img src="/images/posts/hash3.png" alt="" /></p>

<p style="text-align:center;"><img src="/images/posts/hash4.png" alt="" /></p>

<p>How can we accomplish the detection now? Well, there are many many ways. I&rsquo;m going to diver the machine learning path. We will train a neural network with many examples of &lsquo;x&rsquo; and &lsquo;o&rsquo;, in such way that the next time the user draw any of them, the classifier will know which of them the user drew. Once we know that, we just need to check the alignment and ta-dah! Very simple.</p>

<p>Obviously, we can&rsquo;t train with the raw images (because their dimension vary. we could draw at a time a big &lsquo;x&rsquo; and then a small &lsquo;x&rsquo;. we could resize, we then we were performing distortions). We need a feature descriptor. In this example, I&rsquo;m going to user a <strong>Histogram of oriented gradients</strong>, because it makes the most sense, since the &lsquo;x&rsquo; symbol have a very different gradient than a &lsquo;o&rsquo;.</p>

<p>Ok, ok, calm down!!! What is a <em>gradient</em> you are talking about, exactly?</p>

<p>In Calculus, <em>gradient</em> is the rate of change of a function at a given point. Just see image below:</p>

<p style="text-align:center;"><img src="/images/posts/gradient.jpg" alt="" /></p>

<p>This represent the gradient of the f(x) = x<sup>2</sup> function. Obviously, since we are squaring &lsquo;x&rsquo;, higher values of &lsquo;x&rsquo; outputs much higher values of f(x) than lower values of &lsquo;x&rsquo;. Thus, the gradient on the left side is negative (since it is the direction which f(x) changes most) and has a increasing values as &lsquo;x&rsquo; increase. The same can be said about the right side, but with oposite direction.</p>

<p>But what does it have to do with images? Can we calculate gradients of images? Of course yes!!! Images are nothing else than 2D discrete functions.</p>

<p style="text-align:center;"><img src="/images/posts/gradient_images.png" alt="" /></p>

<p>Since we can&rsquo;t know exactly the f(x) for a image, we need to calculate an approximation for the gradient, calculating the difference between two neighbors pixels for each dimension. In fact, this is exactly what the <a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel filter</a> does.</p>

<p>In possession of both gradients on &lsquo;x&rsquo; and &lsquo;y&rsquo; direction, we can calculate the angle to which the gradient is pointing to by taking the inverse tangent of x and y. For the &lsquo;x&rsquo; symbol, the gradient will point alongside the edges (thus only two directions) while for the &lsquo;o&rsquo; symbol, the gradient will tangent each pixel, and since it&rsquo;s a ellipse, we are going to have gradients pointing to many directions. That way we can distinguish a symbol from another.</p>

<p style="text-align:center;"><img src="/images/posts/hog.jpg" alt="" /></p>

<p>Enough talking!! Let&rsquo;s see the code:</p>

<pre><code class="c++ hash.cpp">std::vector&lt;float&gt; getHistogramOfOrientations(cv::Mat &amp;component)
{
    std::vector&lt;float&gt; histogramOfOrientations(HISTOGRAM_SIZE, 0.0f);
    cv::Mat gradX, gradY;
    cv::Sobel(component, gradX, CV_32F, 1, 0, 3, 1, 0, cv::BORDER_DEFAULT);
    cv::Sobel(component, gradY, CV_32F, 0, 1, 3, 1, 0, cv::BORDER_DEFAULT);
    float *gradXPtr = (float*)gradX.data;
    float *gradYPtr = (float*)gradY.data;
    float sum = 0;
    for (int i = 0, end = gradX.rows * gradX.cols; i &lt; end; i++)
    {
        float x = *gradXPtr;
        float y = *gradYPtr;  
        float orientation = (std::atan2(y, x) + M_PI) * 180 / M_PI;
        float norm = std::sqrt(std::pow(x, 2) + std::pow(y, 2));
        histogramOfOrientations[(int)(orientation / (360.0f / HISTOGRAM_SIZE)) % HISTOGRAM_SIZE] += norm;
        sum += norm;
        ++gradXPtr;
        ++gradYPtr;
    }
    for (int i = 0; i &lt; HISTOGRAM_SIZE; i++)
    {
        histogramOfOrientations[i] /= sum;
    }
    return histogramOfOrientations; 
}
</code></pre>

<p>Set a variable named HISTOGRAM_SIZE to determine the number of bins of the histogram (lower values are better, due to the curse of dimensionality thing).</p>

<p>Training the classifier is pretty straight-forward also, once we have the histograms of each sample:</p>

<pre><code class="c++ hash.cpp">void learnClassifier()
{
    cv::Mat trainSamples(3 * NUM_DRAWINGS, HISTOGRAM_SIZE, CV_32F);
    cv::Mat trainResponses = cv::Mat::zeros(3 * NUM_DRAWINGS, 3, CV_32F);
    for (int classId = 0; classId &lt; 3; classId++)
    {
        for (int sampleId = 0; sampleId &lt; NUM_DRAWINGS; sampleId++)
        {
            for (int featureId = 0; featureId &lt; HISTOGRAM_SIZE; featureId++)
            {
                trainSamples.at&lt;float&gt;(classId * NUM_DRAWINGS + sampleId, featureId) = gFeatures[classId][sampleId][featureId];
            }
            trainResponses.at&lt;float&gt;(classId * NUM_DRAWINGS + sampleId, classId) = 1.0f;
        }
    }
    gNeuralNetwork = cv::ml::ANN_MLP::create();
    std::vector&lt;int&gt; layerSizes = { HISTOGRAM_SIZE, HISTOGRAM_SIZE * 4, 3 };
    gNeuralNetwork-&gt;setLayerSizes(layerSizes);
    gNeuralNetwork-&gt;setActivationFunction(cv::ml::ANN_MLP::SIGMOID_SYM);
    gNeuralNetwork-&gt;train(trainSamples, cv::ml::ROW_SAMPLE, trainResponses);
    gNeuralNetwork-&gt;save("mlp.yaml");
}
</code></pre>

<p><code>NUM_DRAWINGS</code> is the number of samples for each class. The samples are stored in a 3D array named <code>gFeatures</code>. Pay special attention to the <code>layerSizes</code> variables. It&rsquo;s the variable which determines the number of neurons for each layer. It has a profound impact in the performance of a neural network.</p>

<p>Finally, we just need to get the label associated to each component, group them and check their alignment.</p>

<pre><code class="c++ hash.cpp">bool checkWinner(const std::vector&lt;cv::Rect&gt; &amp;cells)
{
    if (cells.size() == 3)
    {
        std::vector&lt;cv::Rect&gt; horizontalLine = { cells[0] };
        std::vector&lt;cv::Rect&gt; verticalLine = { cells[0] };
        std::vector&lt;cv::Rect&gt; diagonal = { cells[0] };
        int x1s = cells[0].x;
        int x1e = cells[0].x + cells[0].width;
        int y1s = cells[0].y;
        int y1e = cells[0].y + cells[0].height;
        for (size_t i = 1; i &lt; cells.size(); i++)
        {
            int x2s = cells[i].x;
            int x2e = cells[i].x + cells[i].width;
            int y2s = cells[i].y;
            int y2e = cells[i].y + cells[i].height;
            if (x2s &gt;= x1s &amp;&amp; x2s &lt;= x1e || x1s &gt;= x2s &amp;&amp; x1s &lt;= x2e)
            {
                verticalLine.push_back(cells[i]);
            }
            else if (y2s &gt;= y1s &amp;&amp; y2s &lt;= y1e || y1s &gt;= y2s &amp;&amp; y1s &lt;= y2e)
            {
                horizontalLine.push_back(cells[i]);
            }
            else if (y2s &gt; diagonal[i].y &amp;&amp; x2s &gt; diagonal[i].x
                &amp;&amp; y2e &gt; diagonal[i].y + diagonal[i].height &amp;&amp; x2e &gt; diagonal[i].x + diagonal[i].width)
            {
                diagonal.push_back(cells[i]);
            }
            if (horizontalLine.size() == 3) 
            {
                drawHorizontalLine(horizontalLine);
                return true;
            }
            if (verticalLine.size() == 3)
            {
                drawVerticalLine(verticalLine);
                return true;
            }
            if (diagonal.size() == 3)
            {
                drawDiagonalLine(diagonal);
                return true;
            }
        }
    }
    return false;
}
</code></pre>

<p>In the final code I included many more details, such as asking the user to draw some examples of &lsquo;x&rsquo; and &lsquo;o&rsquo; so the neural network have samples to train on. See it below:</p>

<p><strong>FINAL CODE</strong></p>

<center><input id="spoiler" type="button" value="See source code" onclick="toggle_visibility('code');"></center>


<div id="code">
<figure class='code'><figcaption><span>hash.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;map&gt;</span>
</span><span class='line'><span class="cp">#include &lt;fstream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/core/core.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/highgui/highgui.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/imgproc/imgproc.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/ml/ml.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define STATE_DRAW_X 0</span>
</span><span class='line'><span class="cp">#define STATE_DRAW_O 1</span>
</span><span class='line'><span class="cp">#define STATE_PLAY 2</span>
</span><span class='line'><span class="cp">#define NUM_DRAWINGS 5</span>
</span><span class='line'><span class="cp">#define HISTOGRAM_SIZE 8</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span> <span class="n">gMouseDown</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">gImg</span><span class="p">;</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span> <span class="n">gMousePosition</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">gFeatures</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">gCurrentState</span> <span class="o">=</span> <span class="n">STATE_DRAW_X</span><span class="p">;</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">&gt;</span> <span class="n">gNeuralNetwork</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">getHistogramOfOrientations</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">component</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">histogramOfOrientations</span><span class="p">(</span><span class="n">HISTOGRAM_SIZE</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">gradX</span><span class="p">,</span> <span class="n">gradY</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Sobel</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">gradX</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">BORDER_DEFAULT</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Sobel</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">gradY</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">BORDER_DEFAULT</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">float</span> <span class="o">*</span><span class="n">gradXPtr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">gradX</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">float</span> <span class="o">*</span><span class="n">gradYPtr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">gradY</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">gradX</span><span class="p">.</span><span class="n">rows</span> <span class="o">*</span> <span class="n">gradX</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">gradXPtr</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="o">*</span><span class="n">gradYPtr</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">float</span> <span class="n">orientation</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">atan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">M_PI</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">M_PI</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">float</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
</span><span class='line'>        <span class="n">histogramOfOrientations</span><span class="p">[(</span><span class="kt">int</span><span class="p">)(</span><span class="n">orientation</span> <span class="o">/</span> <span class="p">(</span><span class="mf">360.0f</span> <span class="o">/</span> <span class="n">HISTOGRAM_SIZE</span><span class="p">))</span> <span class="o">%</span> <span class="n">HISTOGRAM_SIZE</span><span class="p">]</span> <span class="o">+=</span> <span class="n">norm</span><span class="p">;</span>
</span><span class='line'>        <span class="n">sum</span> <span class="o">+=</span> <span class="n">norm</span><span class="p">;</span>
</span><span class='line'>        <span class="o">++</span><span class="n">gradXPtr</span><span class="p">;</span>
</span><span class='line'>        <span class="o">++</span><span class="n">gradYPtr</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HISTOGRAM_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">histogramOfOrientations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">sum</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">histogramOfOrientations</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">getComponentImg</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pixels</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="o">&amp;</span><span class="n">boundingRect</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">minX</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">,</span> <span class="n">maxX</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">,</span> <span class="n">minY</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">,</span> <span class="n">maxY</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pixels</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span> <span class="n">pixel</span> <span class="o">=</span> <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">pixel</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">minX</span><span class="p">)</span> <span class="n">minX</span> <span class="o">=</span> <span class="n">pixel</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">pixel</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxX</span><span class="p">)</span> <span class="n">maxX</span> <span class="o">=</span> <span class="n">pixel</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">pixel</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">minY</span><span class="p">)</span> <span class="n">minY</span> <span class="o">=</span> <span class="n">pixel</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">pixel</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">maxY</span><span class="p">)</span> <span class="n">maxY</span> <span class="o">=</span> <span class="n">pixel</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">boundingRect</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="p">(</span><span class="n">minX</span><span class="p">,</span> <span class="n">minY</span><span class="p">,</span> <span class="n">maxX</span> <span class="o">-</span> <span class="n">minX</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="n">maxY</span> <span class="o">-</span> <span class="n">minY</span> <span class="o">+</span> <span class="mi">20</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="n">boundingRect</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">boundingRect</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pixels</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span> <span class="n">pixel</span> <span class="o">=</span> <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundingRect</span><span class="p">.</span><span class="n">tl</span><span class="p">()</span> <span class="o">+</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span><span class='line'>        <span class="n">img</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pixel</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pixel</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">img</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">getConnectedComponents</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">labels</span><span class="p">(</span><span class="n">gImg</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">gImg</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_32S</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">connectedComponents</span><span class="p">(</span><span class="n">gImg</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span><span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">labels</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">components</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">labels</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">labels</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">label</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// not background</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">components</span><span class="p">[</span><span class="o">*</span><span class="n">label</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="o">++</span><span class="n">label</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">connectedComponents</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&gt;</span> <span class="n">imgs</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="n">rects</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">components</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">components</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="n">boundingRect</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="n">getComponentImg</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">boundingRect</span><span class="p">);</span>
</span><span class='line'>        <span class="n">connectedComponents</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">boundingRect</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">connectedComponents</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">getComponentLabel</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">component</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">histogram</span> <span class="o">=</span> <span class="n">getHistogramOfOrientations</span><span class="p">(</span><span class="n">component</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">sample</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">HISTOGRAM_SIZE</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">,</span> <span class="n">histogram</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">predictions</span><span class="p">;</span>
</span><span class='line'>    <span class="n">gNeuralNetwork</span><span class="o">-&gt;</span><span class="n">predict</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">predictions</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">predictions</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">predictions</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">label</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">label</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">learnClassifier</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">trainSamples</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">NUM_DRAWINGS</span><span class="p">,</span> <span class="n">HISTOGRAM_SIZE</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">trainResponses</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">NUM_DRAWINGS</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">classId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">classId</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">classId</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sampleId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sampleId</span> <span class="o">&lt;</span> <span class="n">NUM_DRAWINGS</span><span class="p">;</span> <span class="n">sampleId</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">featureId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">featureId</span> <span class="o">&lt;</span> <span class="n">HISTOGRAM_SIZE</span><span class="p">;</span> <span class="n">featureId</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">trainSamples</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">classId</span> <span class="o">*</span> <span class="n">NUM_DRAWINGS</span> <span class="o">+</span> <span class="n">sampleId</span><span class="p">,</span> <span class="n">featureId</span><span class="p">)</span> <span class="o">=</span> <span class="n">gFeatures</span><span class="p">[</span><span class="n">classId</span><span class="p">][</span><span class="n">sampleId</span><span class="p">][</span><span class="n">featureId</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">trainResponses</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">classId</span> <span class="o">*</span> <span class="n">NUM_DRAWINGS</span> <span class="o">+</span> <span class="n">sampleId</span><span class="p">,</span> <span class="n">classId</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">gNeuralNetwork</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">layerSizes</span> <span class="o">=</span> <span class="p">{</span> <span class="n">HISTOGRAM_SIZE</span><span class="p">,</span> <span class="n">HISTOGRAM_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
</span><span class='line'>    <span class="n">gNeuralNetwork</span><span class="o">-&gt;</span><span class="n">setLayerSizes</span><span class="p">(</span><span class="n">layerSizes</span><span class="p">);</span>
</span><span class='line'>    <span class="n">gNeuralNetwork</span><span class="o">-&gt;</span><span class="n">setActivationFunction</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">::</span><span class="n">SIGMOID_SYM</span><span class="p">);</span>
</span><span class='line'>    <span class="n">gNeuralNetwork</span><span class="o">-&gt;</span><span class="n">train</span><span class="p">(</span><span class="n">trainSamples</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ROW_SAMPLE</span><span class="p">,</span> <span class="n">trainResponses</span><span class="p">);</span>
</span><span class='line'>    <span class="n">gNeuralNetwork</span><span class="o">-&gt;</span><span class="n">save</span><span class="p">(</span><span class="s">&quot;mlp.yaml&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">drawHorizontalLine</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">cells</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">minX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cells</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">cells</span><span class="p">[</span><span class="n">minX</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="n">minX</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxX</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="n">maxX</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span> <span class="n">p1</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">minX</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">cells</span><span class="p">[</span><span class="n">minX</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="n">minX</span><span class="p">].</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span> <span class="n">p2</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">maxX</span><span class="p">].</span><span class="n">x</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxX</span><span class="p">].</span><span class="n">width</span><span class="p">,</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxX</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxX</span><span class="p">].</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span><span class="p">(</span><span class="n">gImg</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">gImg</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">line</span><span class="p">(</span><span class="n">gImg</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">drawVerticalLine</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">cells</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">minY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cells</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">cells</span><span class="p">[</span><span class="n">minY</span><span class="p">].</span><span class="n">y</span><span class="p">)</span> <span class="n">minY</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxY</span><span class="p">].</span><span class="n">y</span><span class="p">)</span> <span class="n">maxY</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span> <span class="n">p1</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">minY</span><span class="p">].</span><span class="n">x</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="n">minY</span><span class="p">].</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cells</span><span class="p">[</span><span class="n">minY</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span> <span class="n">p2</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">maxY</span><span class="p">].</span><span class="n">x</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxY</span><span class="p">].</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxY</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxY</span><span class="p">].</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">line</span><span class="p">(</span><span class="n">gImg</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">drawDiagonalLine</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">cells</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">minY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cells</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">cells</span><span class="p">[</span><span class="n">minY</span><span class="p">].</span><span class="n">y</span><span class="p">)</span> <span class="n">minY</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxY</span><span class="p">].</span><span class="n">y</span><span class="p">)</span> <span class="n">maxY</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span> <span class="n">p1</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">minY</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">cells</span><span class="p">[</span><span class="n">minY</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span> <span class="n">p2</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">maxY</span><span class="p">].</span><span class="n">x</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxY</span><span class="p">].</span><span class="n">width</span><span class="p">,</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxY</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="n">maxY</span><span class="p">].</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">line</span><span class="p">(</span><span class="n">gImg</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span> <span class="n">checkWinner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">cells</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">cells</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="n">horizontalLine</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">};</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="n">verticalLine</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">};</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="n">diagonal</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">};</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">x1s</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">x1e</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">y1s</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">y1e</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">height</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cells</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">x2s</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">x2e</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">y2s</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">y2e</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">height</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">x2s</span> <span class="o">&gt;=</span> <span class="n">x1s</span> <span class="o">&amp;&amp;</span> <span class="n">x2s</span> <span class="o">&lt;=</span> <span class="n">x1e</span> <span class="o">||</span> <span class="n">x1s</span> <span class="o">&gt;=</span> <span class="n">x2s</span> <span class="o">&amp;&amp;</span> <span class="n">x1s</span> <span class="o">&lt;=</span> <span class="n">x2e</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">verticalLine</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">y2s</span> <span class="o">&gt;=</span> <span class="n">y1s</span> <span class="o">&amp;&amp;</span> <span class="n">y2s</span> <span class="o">&lt;=</span> <span class="n">y1e</span> <span class="o">||</span> <span class="n">y1s</span> <span class="o">&gt;=</span> <span class="n">y2s</span> <span class="o">&amp;&amp;</span> <span class="n">y1s</span> <span class="o">&lt;=</span> <span class="n">y2e</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">horizontalLine</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">y2s</span> <span class="o">&gt;</span> <span class="n">diagonal</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x2s</span> <span class="o">&gt;</span> <span class="n">diagonal</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span>
</span><span class='line'>                <span class="o">&amp;&amp;</span> <span class="n">y2e</span> <span class="o">&gt;</span> <span class="n">diagonal</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">diagonal</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">x2e</span> <span class="o">&gt;</span> <span class="n">diagonal</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">+</span> <span class="n">diagonal</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">width</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">diagonal</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">horizontalLine</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">drawHorizontalLine</span><span class="p">(</span><span class="n">horizontalLine</span><span class="p">);</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">verticalLine</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">drawVerticalLine</span><span class="p">(</span><span class="n">verticalLine</span><span class="p">);</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">diagonal</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">drawDiagonalLine</span><span class="p">(</span><span class="n">diagonal</span><span class="p">);</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">processHash</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="o">&gt;</span>  <span class="n">components</span> <span class="o">=</span> <span class="n">getConnectedComponents</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="n">xs</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="n">os</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">size_t</span> <span class="n">biggestComponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">components</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">.</span><span class="n">rows</span> <span class="o">*</span> <span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">.</span><span class="n">cols</span> <span class="o">&gt;</span>
</span><span class='line'>            <span class="n">components</span><span class="p">[</span><span class="n">biggestComponent</span><span class="p">].</span><span class="n">first</span><span class="p">.</span><span class="n">rows</span> <span class="o">*</span> <span class="n">components</span><span class="p">[</span><span class="n">biggestComponent</span><span class="p">].</span><span class="n">first</span><span class="p">.</span><span class="n">cols</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">biggestComponent</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">components</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">biggestComponent</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// the biggest component is obviously the hash</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">label</span> <span class="o">=</span> <span class="n">getComponentLabel</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">label</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">xs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">label</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">os</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">label</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">checkWinner</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">checkWinner</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">addDrawingFeature</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">components</span> <span class="o">=</span> <span class="n">getConnectedComponents</span><span class="p">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">components</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="c1">// user didn&#39;t draw anything</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">components</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// user drew more than one thing, then select the biggest thing</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">biggestComponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">components</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">.</span><span class="n">rows</span> <span class="o">*</span> <span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">.</span><span class="n">cols</span> <span class="o">&gt;</span>
</span><span class='line'>                <span class="n">components</span><span class="p">[</span><span class="n">biggestComponent</span><span class="p">].</span><span class="n">first</span><span class="p">.</span><span class="n">rows</span> <span class="o">*</span> <span class="n">components</span><span class="p">[</span><span class="n">biggestComponent</span><span class="p">].</span><span class="n">first</span><span class="p">.</span><span class="n">cols</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">biggestComponent</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">biggestComponent</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">histogram</span> <span class="o">=</span> <span class="n">getHistogramOfOrientations</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">);</span>
</span><span class='line'>    <span class="n">gFeatures</span><span class="p">[</span><span class="n">gCurrentState</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">histogram</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">gFeatures</span><span class="p">[</span><span class="n">gCurrentState</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">NUM_DRAWINGS</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="o">++</span><span class="n">gCurrentState</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">gCurrentState</span> <span class="o">==</span> <span class="n">STATE_PLAY</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">learnClassifier</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">mouseCallback</span><span class="p">(</span><span class="kt">int</span> <span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">cv</span><span class="o">::</span><span class="n">EVENT_LBUTTONDOWN</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">gMouseDown</span> <span class="o">=</span> <span class="o">!</span><span class="n">gMouseDown</span><span class="p">;</span>
</span><span class='line'>        <span class="n">gMousePosition</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">cv</span><span class="o">::</span><span class="n">EVENT_RBUTTONDOWN</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">gCurrentState</span> <span class="o">==</span> <span class="n">STATE_DRAW_X</span> <span class="o">||</span>
</span><span class='line'>            <span class="n">gCurrentState</span> <span class="o">==</span> <span class="n">STATE_DRAW_O</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">addDrawingFeature</span><span class="p">();</span>
</span><span class='line'>            <span class="n">gImg</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">processHash</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">cv</span><span class="o">::</span><span class="n">EVENT_MBUTTONDOWN</span> <span class="o">&amp;&amp;</span> <span class="n">gCurrentState</span> <span class="o">==</span> <span class="n">STATE_PLAY</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">gImg</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">cv</span><span class="o">::</span><span class="n">EVENT_MOUSEMOVE</span> <span class="o">&amp;&amp;</span> <span class="n">gMouseDown</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">line</span><span class="p">(</span><span class="n">gImg</span><span class="p">,</span> <span class="n">gMousePosition</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">gMousePosition</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="n">gImg</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">CV_GRAY2BGR</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">gCurrentState</span> <span class="o">==</span> <span class="n">STATE_DRAW_X</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
</span><span class='line'>        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Draw a &#39;X&#39; and then right-click (&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">gFeatures</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">NUM_DRAWINGS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">putText</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">(),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">FONT_HERSHEY_SIMPLEX</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gCurrentState</span> <span class="o">==</span> <span class="n">STATE_DRAW_O</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
</span><span class='line'>        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Draw a &#39;O&#39; and then right-click (&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">gFeatures</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">NUM_DRAWINGS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">putText</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">(),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">FONT_HERSHEY_SIMPLEX</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">&quot;Hash&quot;</span><span class="p">,</span> <span class="n">img</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">loadClassifier</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">input</span><span class="p">(</span><span class="s">&quot;mlp.yaml&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">input</span><span class="p">.</span><span class="n">good</span><span class="p">())</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">input</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span><span class='line'>    <span class="n">gNeuralNetwork</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">::</span><span class="n">load</span><span class="p">(</span><span class="s">&quot;mlp.yaml&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">gCurrentState</span> <span class="o">=</span> <span class="n">STATE_PLAY</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">gImg</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">);</span>
</span><span class='line'>    <span class="n">loadClassifier</span><span class="p">();</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">namedWindow</span><span class="p">(</span><span class="s">&quot;Hash&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">setMouseCallback</span><span class="p">(</span><span class="s">&quot;Hash&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mouseCallback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">&quot;Hash&quot;</span><span class="p">,</span> <span class="n">gImg</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eye Tracking for Mouse Control in OpenCV]]></title>
    <link href="http://abner-math.github.io/blog/2017/01/28/eyeball-tracking-for-mouse-control-in-opencv/"/>
    <updated>2017-01-28T08:27:31-03:00</updated>
    <id>http://abner-math.github.io/blog/2017/01/28/eyeball-tracking-for-mouse-control-in-opencv</id>
    <content type="html"><![CDATA[<p>In this tutorial I will show you how you can control your mouse using only a simple webcam. Nothing fancy, super simple to implementate. Let&rsquo;s get on!</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/jBXS1fbMDjE" frameborder="0" allowfullscreen></iframe>




<!-- more -->


<p>First things&#8217; first. We are going to use <a href="http://opencv.org/">OpenCV</a>, an open-source computer vision library. You can find how to set up it <a href="http://docs.opencv.org/2.4/doc/tutorials/introduction/table_of_content_introduction/table_of_content_introduction.html#table-of-content-introduction">here</a>.</p>

<h2>Reading the webcam</h2>

<p>Let&rsquo;s adopt a baby-steps approach. The very first thing we need is to read the webcam image itself. You can do it through the <code>VideoCapture</code> class in the OpenCV <code>highgui</code> module. <code>VideoCapture</code> takes one parameter, the webcam index or a path to a video.</p>

<pre><code class="c++ eye_detector.cpp">#include &lt;iostream&gt;

#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;opencv2/objdetect/objdetect.hpp&gt; 

int main()
{
    cv::VideoCapture cap(0); // the fist webcam connected to your PC
    if (!cap.isOpened())
    {
        std::cerr &lt;&lt; "Webcam not detected." &lt;&lt; std::endl;
        return -1;
    }
    cv::Mat frame;
    while (1)
    {
        cap &gt;&gt; frame; // outputs the webcam image to a Mat
        cv::imshow("Webcam", frame); // displays the Mat
        if (cv::waitKey(30) &gt;= 0) break; // takes 30 frames per second. if the user presses any button, it stops from showing the webcam
    }
    return 0;
}
</code></pre>

<p>I took the liberty of including some OpenCV modules besides the necessary because we are going to need them in the future.</p>

<p>Compile it with this Makefile:</p>

<pre><code class="Make Makefile">CPP_FLAGS=-std=c++11
OPENCV_LIBS: -lopencv_core -lopencv_highgui -lopencv_imgproc -lopencv_objdetect -lopencv_imgcodecs -lopencv_videoio
LD_FLAGS=$(OPENCV_LIBS)

default: EyeDetector
EyeDetector: eye_detector.cpp
    g++ $(CPP_FLAGS) $^ -o $@ $(LD_FLAGS)
clean:
    rm -f EyeDetector
</code></pre>

<p style="text-align:center;"><img src="/images/posts/eye1.png" alt="" /></p>

<p>Now you can see that it&rsquo;s displaying the webcam image. That&rsquo;s something!</p>

<p>Now let&rsquo;s get into the computer vision stuff!</p>

<h2>Face and eye detection with Viola-Jones algorithm (Theory)</h2>

<p>Here&rsquo;s a bit of theory (you can skip it and go to the next section if you are just not interested): Humans can detect a face very easily, but computers do not. When an image is prompted to the computer, all that it &ldquo;sees&rdquo; is a matrix of numbers. So, given that matrix, how can it predict if it represents or not a face? Answer: Building probability distribuitions through thousands of samples of faces and non-faces. And it&rsquo;s the role of a <strong>classifier</strong> to build those probability distribuitions. But here&rsquo;s the thing: A regular image is composed by thousands of pixels. Even a small 28x28 image is composed by 784 pixels. Each pixel can assume 255 values (if the image is using 8-bits grayscale representation). So that&rsquo;s 255<sup>784</sup> number of possible values. Wow! Estimate probability distribuitions with some many variables is not feasible. This is where the Viola-Jones algorithm kicks in: It extracts a much simpler representations of the image, and combine those simple representations into more high-level representations in a hierarchical way, making the problem in the highest level of representation much more simpler and easier than it would be using the original image. Let&rsquo;s see all the steps of this algorithm.</p>

<h3>Haar-like Feature Extraction</h3>

<p>We have some primitive &ldquo;masks&rdquo;, as shown below:</p>

<p style="text-align:center;"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Prm_VJ_fig1_featureTypesWithAlpha.png/600px-Prm_VJ_fig1_featureTypesWithAlpha.png" alt="" /></p>

<p>Those masks are slided over the image, and the sum of the values of the pixels within the &ldquo;white&rdquo; sides is subtracted from the &ldquo;black&rdquo; sides. Now the result is a <strong>feature</strong> that represents that region (a whole region summarized in a number).</p>

<h3>Weak classifiers</h3>

<p>Next step is to train many simple classifiers. Each classifier for each kind of mask. Those simple classifiers work as follows: Takes all the features (extracted from its corresponding mask) within the face region and all the features outside the face region, and label them as &ldquo;face&rdquo; or &ldquo;non-face&rdquo; (two classes). It then learns to distinguish features belonging to a face region from features belonging to a non-face region through a simple <strong>threshold function</strong> (i.e., faces features generally have value above or below a certain value, otherwise it&rsquo;s a non-face). This classifier itself is very bad and is almost as good as random guesting. But if combined, they can arise a much better and stronger classifier (weak classifiers, unite!)</p>

<h3>Cascading classifiers</h3>

<p>Given a region, I can submit it to many weak classifiers, as shown above. Each weak classifier will output a number, 1 if it predicted the region as belonging to a face region or 0 otherwise. This result can be weighted. The sum of all weak classifiers weighted outputed results in another <strong>feature</strong>, that, again, can be inputted to another classifier. It&rsquo;s said that that new classifier is a <strong>linear combination</strong> of other classifiers. Its role is to determine the right weight values such as the error be as minimum as possible.</p>

<h3>What about eyes?</h3>

<p>Well, eyes follow the same principle as face detection. But now, if we have a face detector previously trained, the problem becomes sightly simpler, since the eyes will be always located in the face region, reducing dramatically our search space.</p>

<h2>Face and eye detection with Viola-Jones algorithm (practice)</h2>

<p>Thankfully, the above algorithm is already implemented in OpenCV and a classifier using thousands and thousands of faces was already trained for us!</p>

<p>Let&rsquo;s start by reading the trained models. You can download them <a href="https://github.com/opencv/opencv/tree/master/data/haarcascades">here</a>. Put them in the same directory as the .cpp file.</p>

<pre><code class="c++ eye_detector.cpp">int main()
{
    cv::CascadeClassifier faceCascade;
    cv::CascadeClassifier eyeCascade;
    if (!faceCascade.load("./haarcascade_frontalface_alt.xml"))
    {
        std::cerr &lt;&lt; "Could not load face detector." &lt;&lt; std::endl;
        return -1;
    }
    if (!eyeCascade.load("./haarcascade_eye_tree_eyeglasses.xml"))
    {
        std::cerr &lt;&lt; "Could not load eye detector." &lt;&lt; std::endl;
        return -1;
    }
    ...
}
</code></pre>

<p>Now let&rsquo;s modify our loop to include a call to a function named <code>detectEyes</code>:</p>

<pre><code class="c++ eye_detector.cpp">
int main()
{
    ...
    while (1)
    {
        ...
        detectEyes(frame, faceCascade, eyeCascade);
        cv::imshow("Webcam", frame);
        if (cv::waitKey(30) &gt;= 0) break;
    }
    return 0;
}
</code></pre>

<p>Let&rsquo;s implement that function:</p>

<pre><code class="c++ eye_detector.cpp">void detectEyes(cv::Mat &amp;frame, cv::CascadeClassifier &amp;faceCascade, cv::CascadeClassifier &amp;eyeCascade)
{
    cv::Mat grayscale;
    cv::cvtColor(frame, grayscale, CV_BGR2GRAY); // convert image to grayscale
    cv::equalizeHist(grayscale, grayscale); // enhance image contrast 
    std::vector&lt;cv::Rect&gt; faces;
    faceCascade.detectMultiScale(grayscale, faces, 1.1, 2, 0 | CV_HAAR_SCALE_IMAGE, cv::Size(150, 150));
}
</code></pre>

<p>A break to explain the <code>detectMultiScale</code> method. It takes the following arguments:</p>

<ul>
<li>inputImage: The input image</li>
<li>faces: A vector of rects where the faces were detected</li>
<li>scaleFactor: The classifier will try to upscale and downscale the image in a certain factor (in the above case, in 1.1). It will help to detect faces with more accuracy.</li>
<li>minNumNeighbors: How many true-positive neighbor rectangles do you want to assure before predicting a region as a face? The higher this face, the lower the chance of detecting a non-face as face, but also lower the chance of detecting a face as face.</li>
<li>flags: Some flags. In the above case, we want to scale the image.</li>
<li>minSize: The minimum size which a face can have in our image. A poor quality webcam has frames with 640x480 resolution. So 150x150 is more than enough to cover a face in it.</li>
</ul>


<p>Let&rsquo;s proceed. Now we have the faces detected in the vector <code>faces</code>. What to do next? Eye detection!</p>

<pre><code class="c++ eye_detector.cpp">void detectEyes(...)
{
    ...
    if (faces.size() == 0) return; // none face was detected
    cv::Mat face = frame(faces[0]); // crop the face
    std::vector&lt;cv::Rect&gt; eyes;
    eyeCascade.detectMultiScale(face, eyes, 1.1, 2, 0 | CV_HAAR_SCALE_IMAGE, cv::Size(150, 150)); // same thing as above    
}
</code></pre>

<p>Now we have both face and eyes detected. Let&rsquo;s just test it by drawing the regions where they were detected:</p>

<pre><code class="c++ eye_detector.cpp">void detectEyes(...)
{
    ...
    rectangle(frame, faces[0].tl(), faces[0].br(), cv::Scalar(255, 0, 0), 2);
    if (eyes.size() != 2) return; // both eyes were not detected
    for (cv::Rect &amp;eye : eyes) 
    {
        rectangle(frame, faces[0].tl() + eye.tl(), faces[0].tl() + eye.br(), cv::Scalar(0, 255, 0), 2);
    }
}
</code></pre>

<p style="text-align:center;"><img src="/images/posts/eye2.png" alt="" /></p>

<p>Looking good so far!</p>

<h2>Detecting iris</h2>

<p>Now we have detected the eyes, the next step is to detect the iris. For that, we are going to look for the most &ldquo;circular&rdquo; object in the eye region. Luckily, that&rsquo;s already a function in OpenCV that does just that! It&rsquo;s called <code>HoughCircles</code>, and it works as follows: It first apply an edge detector in the image, from which it make contours and from the contours made it tried to calculate a &ldquo;circularity ratio&rdquo;, i.e., how much that contour looks like a circle.</p>

<p>First we are going to choose one of the eyes to detect the iris. I&rsquo;m going to choose the leftmost.</p>

<pre><code class="c++ eye_detector.cpp">cv::Rect getLeftmostEye(std::vector&lt;cv::Rect&gt; &amp;eyes)
{
    int leftmost = 99999999;
    int leftmostIndex = -1;
    for (int i = 0; i &lt; eyes.size(); i++)
    {
        if (eyes[i].tl().x &lt; leftmost) 
        {
            leftmost = eyes[i].tl().x;
            leftmostIndex = i;
        }
    }
    return eyes[leftmostIndex];
}

void detectEyes(...)
{
    ...
    cv::Rect eyeRect = getLeftmostEye(eyes);
}
</code></pre>

<p>The <code>getLeftmostEye</code> only returns the rect from which the top-left position is leftmost. Nothing serious.</p>

<p>After I got the leftmost eye, I&rsquo;m going to crop it, apply a histogram equalization to enhance constrat and then the <code>HoughCircles</code> function to find the circles in my image.</p>

<pre><code class="c++ eye_detector.cpp">void detectEyes(...)
{
    ...
    cv::Mat eye = face(eyeRect); // crop the leftmost eye
    cv::equalizeHist(eye, eye);
    std::vector&lt;cv::Vec3f&gt; circles;
    cv::HoughCircles(eye, circles, CV_HOUGH_GRADIENT, 1, eye.cols / 8, 250, 15, eye.rows / 8, eye.rows / 3);
}
</code></pre>

<p>Let&rsquo;s take a deep look in what the <code>HoughCircles</code> function expects:</p>

<ul>
<li>inputImage: The input image</li>
<li>circles: The circles that it found</li>
<li>method: Method to be applied</li>
<li>dp: Inverse ratio of the accumulator resolution</li>
<li>minDist: Minimal distance between the center of one circle and another</li>
<li>threshold: Threshold of the edge detector</li>
<li>minArea: What&rsquo;s the min area of a circle in the image?</li>
<li>minRadius: What&rsquo;s the min radius of a circle in the image?</li>
<li>maxRadius: What&rsquo;s the max radius of a circle in the image?</li>
</ul>


<p>Well, that&rsquo;s it&hellip; As the function itself says, it can detect many circles, but we just want one. So let&rsquo;s select the one belonging to the eyeball. For that, I chose a very stupid heuristic: Choose the circle that contains more &ldquo;black&rdquo; pixels in it! In another words, the circle from which the sum of pixels within it is minimal.</p>

<pre><code class="c++ eye_detector.cpp">cv::Vec3f getEyeball(cv::Mat &amp;eye, std::vector&lt;cv::Vec3f&gt; &amp;circles)
{
    std::vector&lt;int&gt; sums(circles.size(), 0);
    for (int y = 0; y &lt; eye.rows; y++)
    {
        uchar *ptr = eye.ptr&lt;uchar&gt;(y);
        for (int x = 0; x &lt; eye.cols; x++)
        {
            int value = static_cast&lt;int&gt;(*ptr);
            for (int i = 0; i &lt; circles.size(); i++)
            {
                cv::Point center((int)std::round(circles[i][0]), (int)std::round(circles[i][1]));
                int radius = (int)std::round(circles[i][2]);
                if (std::pow(x - center.x, 2) + std::pow(y - center.y, 2) &lt; std::pow(radius, 2))
                {
                    sums[i] += value;
                }
            }
            ++ptr;
        }
    }
    int smallestSum = 9999999;
    int smallestSumIndex = -1;
    for (int i = 0; i &lt; circles.size(); i++)
    {
        if (sums[i] &lt; smallestSum)
        {
            smallestSum = sums[i];
            smallestSumIndex = i;
        }
    } 
    return circles[smallestSumIndex];
}

void detectEyes(...)
{
    ...
    if (circles.size() &gt; 0)
    {
        cv::Vec3f eyeball = getEyeball(eye, circles);
    }
}
</code></pre>

<p>In order to know if a pixel is inside a pixel or not, we just test if the euclidean distance between the pixel location and the circle center is not higher than the circle radius. Piece of cake.</p>

<p>That&rsquo;s good, now we supposely have the iris. However, the <code>HoughCircles</code> algorithms is very unstable, and therefore the iris location can vary a lot! We need to stabilize it to get better results. To do that, we simply calculate the mean of the last five detected iris locations.</p>

<pre><code class="c++ eye_detector.cpp">std::vector&lt;cv::Point&gt; centers;

cv::Point stabilize(std::vector&lt;cv::Point&gt; &amp;points, int windowSize)
{
    float sumX = 0;
    float sumY = 0;
    int count = 0;
    for (int i = std::max(0, (int)(points.size() - windowSize)); i &lt; points.size(); i++)
    {
        sumX += points[i].x;
        sumY += points[i].y;
        ++count;
    }
    if (count &gt; 0)
    {
        sumX /= count;
        sumY /= count;
    }
    return cv::Point(sumX, sumY);
}

void detectEyes(...)
{
    ...
    if (circles.size() &gt; 0)
    {
        cv::Vec3f eyeball = getEyeball(eye, circles);
        cv::Point center(eyeball[0], eyeball[1]);
        centers.push_back(center);
        center = stabilize(centers, 5); // we are using the last 5
    }
}
</code></pre>

<p>Finally, let&rsquo;s draw the iris location and test it!</p>

<pre><code class="c++ eye_detector.cpp">void detectEyes(...)
{
    if (circles.size() &gt; 0) 
    {
        ...
        cv::circle(frame, faces[0].tl() + eyeRect.tl() + center, radius, cv::Scalar(0, 0, 255), 2);
        cv::circle(eye, center, radius, cv::Scalar(255, 255, 255), 2);
    }
    cv::imshow("Eye", eye);
}
</code></pre>

<p style="text-align:center;"><img src="/images/posts/eye3.png" alt="" /></p>

<p>Excellent!</p>

<h2>Controlling the mouse</h2>

<p>Well, that&rsquo;s something very specific of the operating system that you&rsquo;re using. I&rsquo;m using Ubuntu, thus I&rsquo;m going to use <code>xdotool</code>. Install xtodo:</p>

<pre><code class="bash">sudo apt-get install xdotool
</code></pre>

<p>In xdotool, the command to move the mouse is:</p>

<pre><code>xdotool mousemove x y
</code></pre>

<p>Alright. Let&rsquo;s just create a variable that defines the mouse position and then set it each time the iris position changes:</p>

<pre><code class="c++ eye_detector.cpp">cv::Point lastPoint;
cv::Point mousePoint;

void detectEyes(...)
{
    if (circles.size() &gt; 0)
    {
        ...
        if (centers.size() &gt; 1)
        {
            cv::Point diff;
            diff.x = (center.x - lastPoint.x) * 20;
            diff.y = (center.x - lastPoint.y) * -30; // diff in y is higher because it's "harder" to move the eyeball up/down instead of left/right
        }
        lastPoint = center;
    }
}

void changeMouse(cv::Mat &amp;frame, cv::Point &amp;location)
{
    if (location.x &gt; frame.cols) location.x = frame.cols;
    if (location.x &lt; 0) location.x = 0;
    if (location.y &gt; frame.rows) location.y = frame.rows;
    if (location.y &lt; 0) location.y = 0;
    system(("xdotool mousemove " + std::to_string(location.x) + " " + std::to_string(location.y)).c_str());
}

int main(...)
{
    ...
    while (1)
    {
        ...
        detectEyes(...);
        changeMouse(frame, mousePoint);
        ...
    }
    return 0;
}
</code></pre>

<p>As you can see, I&rsquo;m taking the difference of position between the current iris position and the previous iris position. Of course, this is not the best option. Ideally, we would detect the &ldquo;gaze direction&rdquo; in relation to difference between the iris position and the &ldquo;rested&rdquo; iris position. I let it for you to implement! Not that hard.</p>

<p>That&rsquo;s it! Here is the full source code:</p>

<center><input id="spoiler" type="button" value="See source code" onclick="toggle_visibility('code');"></center>


<div id="code">
<figure class='code'><figcaption><span>eye_detector.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;opencv2/core/core.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/highgui/highgui.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/imgproc/imgproc.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/objdetect/objdetect.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Vec3f</span> <span class="n">getEyeball</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">eye</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3f</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">circles</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sums</span><span class="p">(</span><span class="n">circles</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">eye</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">uchar</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">eye</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">eye</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</span><span class='line'>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">circles</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="n">center</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">round</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">round</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]));</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">radius</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">round</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="o">++</span><span class="n">ptr</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">smallestSum</span> <span class="o">=</span> <span class="mi">9999999</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">smallestSumIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">circles</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">smallestSum</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">smallestSum</span> <span class="o">=</span> <span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>            <span class="n">smallestSumIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">circles</span><span class="p">[</span><span class="n">smallestSumIndex</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="n">getLeftmostEye</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">eyes</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">leftmost</span> <span class="o">=</span> <span class="mi">99999999</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">leftmostIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">eyes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">eyes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tl</span><span class="p">().</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">leftmost</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">leftmost</span> <span class="o">=</span> <span class="n">eyes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tl</span><span class="p">().</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>            <span class="n">leftmostIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">eyes</span><span class="p">[</span><span class="n">leftmostIndex</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">centers</span><span class="p">;</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="n">lastPoint</span><span class="p">;</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="n">mousePoint</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="n">stabilize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">points</span><span class="p">,</span> <span class="kt">int</span> <span class="n">windowSize</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">sumX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">sumY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">windowSize</span><span class="p">));</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">sumX</span> <span class="o">+=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>        <span class="n">sumY</span> <span class="o">+=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>        <span class="o">++</span><span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">sumX</span> <span class="o">/=</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>        <span class="n">sumY</span> <span class="o">/=</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">sumX</span><span class="p">,</span> <span class="n">sumY</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">detectEyes</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">CascadeClassifier</span> <span class="o">&amp;</span><span class="n">faceCascade</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">CascadeClassifier</span> <span class="o">&amp;</span><span class="n">eyeCascade</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">grayscale</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">grayscale</span><span class="p">,</span> <span class="n">CV_BGR2GRAY</span><span class="p">);</span> <span class="c1">// convert image to grayscale</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">equalizeHist</span><span class="p">(</span><span class="n">grayscale</span><span class="p">,</span> <span class="n">grayscale</span><span class="p">);</span> <span class="c1">// enhance image contrast </span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="n">faces</span><span class="p">;</span>
</span><span class='line'>    <span class="n">faceCascade</span><span class="p">.</span><span class="n">detectMultiScale</span><span class="p">(</span><span class="n">grayscale</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span> <span class="o">|</span> <span class="n">CV_HAAR_SCALE_IMAGE</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">));</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">faces</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// none face was detected</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">face</span> <span class="o">=</span> <span class="n">grayscale</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// crop the face</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="o">&gt;</span> <span class="n">eyes</span><span class="p">;</span>
</span><span class='line'>    <span class="n">eyeCascade</span><span class="p">.</span><span class="n">detectMultiScale</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">eyes</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span> <span class="o">|</span> <span class="n">CV_HAAR_SCALE_IMAGE</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">));</span> <span class="c1">// same thing as above  </span>
</span><span class='line'>    <span class="n">rectangle</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tl</span><span class="p">(),</span> <span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">br</span><span class="p">(),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">eyes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// both eyes were not detected</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="o">&amp;</span><span class="nl">eye</span> <span class="p">:</span> <span class="n">eyes</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">rectangle</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tl</span><span class="p">()</span> <span class="o">+</span> <span class="n">eye</span><span class="p">.</span><span class="n">tl</span><span class="p">(),</span> <span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tl</span><span class="p">()</span> <span class="o">+</span> <span class="n">eye</span><span class="p">.</span><span class="n">br</span><span class="p">(),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="n">eyeRect</span> <span class="o">=</span> <span class="n">getLeftmostEye</span><span class="p">(</span><span class="n">eyes</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">eye</span> <span class="o">=</span> <span class="n">face</span><span class="p">(</span><span class="n">eyeRect</span><span class="p">);</span> <span class="c1">// crop the leftmost eye</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">equalizeHist</span><span class="p">(</span><span class="n">eye</span><span class="p">,</span> <span class="n">eye</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3f</span><span class="o">&gt;</span> <span class="n">circles</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">HoughCircles</span><span class="p">(</span><span class="n">eye</span><span class="p">,</span> <span class="n">circles</span><span class="p">,</span> <span class="n">CV_HOUGH_GRADIENT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">eye</span><span class="p">.</span><span class="n">cols</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">eye</span><span class="p">.</span><span class="n">rows</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">eye</span><span class="p">.</span><span class="n">rows</span> <span class="o">/</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">circles</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Vec3f</span> <span class="n">eyeball</span> <span class="o">=</span> <span class="n">getEyeball</span><span class="p">(</span><span class="n">eye</span><span class="p">,</span> <span class="n">circles</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="n">center</span><span class="p">(</span><span class="n">eyeball</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">eyeball</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">centers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">center</span><span class="p">);</span>
</span><span class='line'>        <span class="n">center</span> <span class="o">=</span> <span class="n">stabilize</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">centers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="n">diff</span><span class="p">;</span>
</span><span class='line'>            <span class="n">diff</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">lastPoint</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span><span class="p">;</span>
</span><span class='line'>            <span class="n">diff</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">lastPoint</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">30</span><span class="p">;</span>
</span><span class='line'>            <span class="n">mousePoint</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">lastPoint</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">radius</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">eyeball</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">circle</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tl</span><span class="p">()</span> <span class="o">+</span> <span class="n">eyeRect</span><span class="p">.</span><span class="n">tl</span><span class="p">()</span> <span class="o">+</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">circle</span><span class="p">(</span><span class="n">eye</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">&quot;Eye&quot;</span><span class="p">,</span> <span class="n">eye</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">changeMouse</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="o">&amp;</span><span class="n">location</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">frame</span><span class="p">.</span><span class="n">cols</span><span class="p">)</span> <span class="n">location</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">location</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">frame</span><span class="p">.</span><span class="n">rows</span><span class="p">)</span> <span class="n">location</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">location</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">system</span><span class="p">((</span><span class="s">&quot;xdotool mousemove &quot;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">y</span><span class="p">)).</span><span class="n">c_str</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Usage: EyeDetector &lt;WEBCAM_INDEX&gt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">CascadeClassifier</span> <span class="n">faceCascade</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">CascadeClassifier</span> <span class="n">eyeCascade</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">faceCascade</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">&quot;./haarcascade_frontalface_alt.xml&quot;</span><span class="p">))</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Could not load face detector.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eyeCascade</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">&quot;./haarcascade_eye_tree_eyeglasses.xml&quot;</span><span class="p">))</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Could not load eye detector.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">VideoCapture</span> <span class="n">cap</span><span class="p">(</span><span class="s">&quot;./sample.mp4&quot;</span><span class="p">);</span> <span class="c1">// the fist webcam connected to your PC</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">.</span><span class="n">isOpened</span><span class="p">())</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Webcam not detected.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="n">mousePoint</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">800</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">cap</span> <span class="o">&gt;&gt;</span> <span class="n">frame</span><span class="p">;</span> <span class="c1">// outputs the webcam image to a Mat</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="n">detectEyes</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">faceCascade</span><span class="p">,</span> <span class="n">eyeCascade</span><span class="p">);</span>
</span><span class='line'>        <span class="n">changeMouse</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">mousePoint</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">&quot;Webcam&quot;</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span> <span class="c1">// displays the Mat</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// takes 30 frames per second. if the user presses any button, it stops from showing the webcam</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Is It a Cat or a Dog? A Neural Network Application in OpenCV]]></title>
    <link href="http://abner-math.github.io/blog/2016/01/31/is-it-a-cat-or-dog-a-neural-network-application-in-opencv/"/>
    <updated>2016-01-31T13:23:41-03:00</updated>
    <id>http://abner-math.github.io/blog/2016/01/31/is-it-a-cat-or-dog-a-neural-network-application-in-opencv</id>
    <content type="html"><![CDATA[<p style="text-align:center;"><img src="/images/posts/ann_dog2.jpg" alt="" /><br><i>Who is the good boy?</i></p>

<p>From time to time, a website named <a href="http://www.kaggle.com">Kaggle</a> hosts several competitions in the fields of Data Science and Computer Vision. One of those competitions was the <a href="https://www.kaggle.com/c/dogs-vs-cats">Dogs vs. Cats</a> challenge, where the objective was &ldquo;to create an algorithm to distinguish dogs from cats&rdquo;. Although this particular challenge already has been finished, I thought that it&rsquo;d give me a pretty good material to a tutorial. Let&rsquo;s learn how to solve this problem together using OpenCV!</p>

<!-- more --> 


<p>Here&rsquo;s a live demo:</p>

<iframe src="http://catordog-picoledelimao.rhcloud.com/" width="100%" height="500px"></iframe>


<h2>Setup environment</h2>

<p>I&rsquo;ll assume that you already have OpenCV 3.0 configured in your machine (if you don&rsquo;t, you can do it <a href="http://docs.opencv.org/2.4/doc/tutorials/introduction/table_of_content_introduction/table_of_content_introduction.html#table-of-content-introduction">here</a>). Also, I&rsquo;ll use the Boost library to read files in a directory (you can perhaps skip it and replace my code by dirent.h. It should work in the same way). You can download Boost <a href="http://www.boost.org/">here</a>. Those are the only two external libraries that I&rsquo;m going to use in this tutorial.</p>

<p>Ok, ok, let&rsquo;s start by downloading the training and test sets. Click <a href="https://www.kaggle.com/c/dogs-vs-cats/data">here</a> and download the <a href="https://www.kaggle.com/c/dogs-vs-cats/download/test1.zip">test1.zip</a> (271.15mb). You may need to register first. After downloading, extract them to a folder of your preference. The training set will be used to adjust the parameters of our neural network (we will talk in details later), while the test set will be used to check the performance of our neural network (how good it is at generalizing unseen examples). Unhappily, the provided test set by Kaggle is not labeled, so we will split the training set (in the provided link) and use a part of it as our test set.</p>

<h2>Reading training samples</h2>

<p>Let&rsquo;s start coding! First, let&rsquo;s start by reading the list of files within the training set directory:</p>

<pre><code class="C++ opencv_ann.cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;fstream&gt;

#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/features2d/features2d.hpp&gt;
#include &lt;opencv2/ml/ml.hpp&gt;

#include &lt;boost/filesystem.hpp&gt;

namespace fs = boost::filesystem;

/**
 * Get all files in directory (not recursive)
 * @param directory Directory where the files are contained
 * @return A list containing the file name of all files inside given directory
 **/
std::vector&lt;std::string&gt; getFilesInDirectory(const std::string&amp; directory)
{
    std::vector&lt;std::string&gt; files;
    fs::path root(directory);
    fs::directory_iterator it_end;
    for (fs::directory_iterator it(root); it != it_end; ++it)
    {
        if (fs::is_regular_file(it-&gt;path()))
        {
            files.push_back(it-&gt;path().string());
        }
    }
    return files;
}


int main(int argc, char** argv)
{
    if (argc != 4)
    {
        std::cerr &lt;&lt; "Usage: &lt;IMAGES_DIRECTORY&gt;  &lt;NETWORK_INPUT_LAYER_SIZE&gt; &lt;TRAIN_SPLIT_RATIO&gt;" &lt;&lt; std::endl;
        exit(-1);
    }
    std::string imagesDir = argv[1];
    int networkInputSize = atoi(argv[2]);
    float trainSplitSize = atof(argv[3]);

    std::cout &lt;&lt; "Reading training set..." &lt;&lt; std::endl;
    double start = (double)cv::getTickCount();
    std::vector&lt;std::string&gt; files = getFilesInDirectory(imagesDir);
    std::random_shuffle(files.begin(), files.end());
}
</code></pre>

<p>The function <code>getFilesInDirectory</code> expects as input a directory and returns a list of filenames within this directory. In our <code>main</code>, we expect to receive three parameters from command line: The directory where our training set is stored, the size of our network input layer and the ratio of our training set (i.e., 0.75 indicates that 75% of the images within the training set will be used to train our neural network while the remaining 25% will be used to test it). We then shuffle the list of filenames (in order to prevent <em>bias</em>). Pretty straight-forward until here, aye? :)</p>

<p>Now we are going to iterate over each filename inside <code>files</code> and read the image associated to it. Since we will do it twice (one during the training step and another during the test step), let&rsquo;s create a function apart in order to modularize our code.</p>

<pre><code>typedef std::vector&lt;std::string&gt;::const_iterator vec_iter;

/**
 * Read images from a list of file names and returns, for each read image,
 * its class name and its local descriptors
 */
void readImages(vec_iter begin, vec_iter end, std::function&lt;void (const std::string&amp;, const cv::Mat&amp;)&gt; callback)
{
    for (auto it = begin; it != end; ++it)
    {
        std::string filename = *it;
        std::cout &lt;&lt; "Reading image " &lt;&lt; filename &lt;&lt; "..." &lt;&lt; std::endl;
        cv::Mat img = cv::imread(filename, 0);
        if (img.empty())
        {
            std::cerr &lt;&lt; "WARNING: Could not read image." &lt;&lt; std::endl;
            continue;
        }
        std::string classname = getClassName(filename);
        cv::Mat descriptors = getDescriptors(img);
        callback(classname, descriptors);
    }
}
</code></pre>

<p>There it is. The <code>readImages</code> function expect to receive as input two vector iterators (one for the start of our vector and another for the end, indicating the range from which we will iterate over). Finally, it expects another third parameter, a lambda function called &ldquo;callback&rdquo; (lambda functions are only available on C++11, so enable it on compiler by adding the <code>-std=c++11</code> flag or <code>-std=c++0x</code> on old compilers). Now let&rsquo;s look more carefuly on what&rsquo;s happening inside this function.</p>

<p>We use a <code>for</code> to iterate over each filename between the limiters <code>begin</code> and <code>end</code>. For each filename, we read its associated image through the OpenCV <code>imread</code> function. The second parameter passed to <code>imread</code> indicates the color space (0 = gray scale. We don&rsquo;t need the color information in this example. You&rsquo;ll find the explanation later). After calling <code>imread</code>, we check if we could really read the image (through the <code>empty</code> method). If don&rsquo;t, we skip to the next filename. Otherwise, we get the class name and the descriptors associated to the read image and return them to the &ldquo;callback&rdquo; function. Now let&rsquo;s implement the <code>getClassName</code> and <code>getDescriptors</code> functions.</p>

<p>If you look at the files inside the training set you extracted, you will find out that they are named as &ldquo;dog.XXXXX.jpg&rdquo; or &ldquo;cat.XXXXX.jpg&rdquo;. The first three letters is always the class name, where the remaining is only an identifier. So let&rsquo;s get those three first letters!</p>

<pre><code>/**
 * Extract the class name from a file name 
 */
inline std::string getClassName(const std::string&amp; filename)
{
    return filename.substr(filename.find_last_of('/') + 1, 3);
}
</code></pre>

<p>Now what should the <code>getDescriptors</code> function looks like? Let&rsquo;s figure out on the next topic.</p>

<h2>Extracting features</h2>

<p>There are several approaches here. We could use the <a href="https://en.wikipedia.org/wiki/Color_histogram"><strong>color histogram</strong></a>, or perhaps the <a href="https://en.wikipedia.org/wiki/Histogram_of_oriented_gradients"><strong>histogram of oriented gradients</strong></a>, etc., &hellip; However, I&rsquo;m going through a different approach. I&rsquo;m going to use the <a href="http://isit.u-clermont1.fr/~ab/Publications/Alcantarilla_Bartoli_Davison_ECCV12.pdf"><strong>KAZE</strong></a> algorithm to extract local features from the image. Since we can&rsquo;t submit local features to a neural network (because the number of descriptors varies), I&rsquo;m also going to use the <a href="https://en.wikipedia.org/wiki/Bag-of-words_model_in_computer_vision"><strong>Bag of words</strong></a> strategy in order to address this problem, turning all set of descriptors into a single <strong>histogram of visual words</strong>, and THAT will be used as input to our neural network. Got it? Excellent! So let&rsquo;s implement the <code>getDescriptors</code> to extract the KAZE features from an image, and later, after all KAZE features had been extracted, we&rsquo;ll apply the Bag of Words technique.</p>

<pre><code>
/**
 * Extract local features for an image
 */
cv::Mat getDescriptors(const cv::Mat&amp; img)
{
    cv::Ptr&lt;cv::KAZE&gt; kaze = cv::KAZE::create();
    std::vector&lt;cv::KeyPoint&gt; keypoints;
    cv::Mat descriptors;
    kaze-&gt;detectAndCompute(img, cv::noArray(), keypoints, descriptors);
    return descriptors;
}
</code></pre>

<p>Ok, now let&rsquo;s go back to our main:</p>

<pre><code>
struct ImageData 
{
    std::string classname;
    cv::Mat bowFeatures;
};

int main(int argc, char** argv)
{
    if (argc != 4)
    {
        std::cerr &lt;&lt; "Usage: &lt;IMAGES_DIRECTORY&gt;  &lt;NETWORK_INPUT_LAYER_SIZE&gt; &lt;TRAIN_SPLIT_RATIO&gt;" &lt;&lt; std::endl;
        exit(-1);
    }
    std::string imagesDir = argv[1];
    int networkInputSize = atoi(argv[2]);
    float trainSplitRatio = atof(argv[3]);

    std::cout &lt;&lt; "Reading training set..." &lt;&lt; std::endl;
    double start = (double)cv::getTickCount();
    std::vector&lt;std::string&gt; files = getFilesInDirectory(imagesDir);
    std::random_shuffle(files.begin(), files.end());

    cv::Mat descriptorsSet;
    std::vector&lt;ImageData*&gt; descriptorsMetadata;
    std::set&lt;std::string&gt; classes;
    readImages(files.begin(), files.begin() + (size_t)(files.size() * trainSplitRatio), 
        [&amp;](const std::string&amp; classname, const cv::Mat&amp; descriptors) {
        // Append to the set of classes
        classes.insert(classname);
        // Append to the list of descriptors
        descriptorsSet.push_back(descriptors);
        // Append metadata to each extracted feature
        ImageData* data = new ImageData;
        data-&gt;classname = classname;
        data-&gt;bowFeatures = cv::Mat::zeros(cv::Size(networkInputSize, 1), CV_32F);
        for (int j = 0; j &lt; descriptors.rows; j++)
        {
            descriptorsMetadata.push_back(data);
        }
    });
    std::cout &lt;&lt; "Time elapsed in minutes: " &lt;&lt; ((double)cv::getTickCount() - start) / cv::getTickFrequency() / 60.0 &lt;&lt; std::endl;
}
</code></pre>

<p>I created a struct named <code>ImageData</code>, with two fields: <code>classname</code> and <code>bowFeatures</code>. Before calling the <code>readImages</code> function, I instanciated three variables: <code>descriptorsSet</code> (the set of descriptors of all read images), <code>descriptorsMetadata</code> (a vector of the struct we previously created. It&rsquo;s being filled in such way that it has the same number of elements as the number of rows of <code>descriptorsSet</code>. That way, the i-th row of <code>descriptorsSet</code> can also be used to access its metadata (the class name, for instance)). And, for last, the <code>classes</code> variables (a set containing all found classes).</p>

<h2>Training the Bag of Words</h2>

<p>Now that we have the whole set of descriptors stored in the <code>descriptorsSet</code> variable, we can apply the Bag of words strategy. The Bag of Words algorithm is really simple: First we use a clustering algorithm (such as <a href="https://en.wikipedia.org/wiki/K-means_clustering"><strong>k-means</strong></a>) to obtain k centroids. Each centroid representates a <strong>visual word</strong> (the set of visual words is often called <strong>vocabulary</strong>). For each image, we create a histogram of size M, where M is the number of visual words. Now, for each extracted descriptor from the image, we measure its distance to all visual words, obtaining the index of the nearest one. We use that index to increment the position of histogram corresponding to that index, obtaining, that way, <strong>a histogram of visual words</strong>, that can later be submitted to our neural network.</p>

<p style="text-align:center;"><img src="/images/posts/ann_2.jpg" alt="" /><br>
Source: <a href="http://www.ifp.illinois.edu/~yuhuang/sceneclassification.html">http://www.ifp.illinois.edu/~yuhuang/sceneclassification.html</a></p>

<pre><code>int main()
{
    ...

    std::cout &lt;&lt; "Creating vocabulary..." &lt;&lt; std::endl;
    start = (double)cv::getTickCount();
    cv::Mat labels;
    cv::Mat vocabulary;
    // Use k-means to find k centroids (the words of our vocabulary)
    cv::kmeans(descriptorsSet, networkInputSize, labels, cv::TermCriteria(cv::TermCriteria::EPS + 
        cv::TermCriteria::MAX_ITER, 10, 0.01), 1, cv::KMEANS_PP_CENTERS, vocabulary);
    // No need to keep it on memory anymore
    descriptorsSet.release();
    std::cout &lt;&lt; "Time elapsed in minutes: " &lt;&lt; ((double)cv::getTickCount() - start) / cv::getTickFrequency() / 60.0 &lt;&lt; std::endl;

    // Convert a set of local features for each image in a single descriptors
    // using the bag of words technique
    std::cout &lt;&lt; "Getting histograms of visual words..." &lt;&lt; std::endl;
    int* ptrLabels = (int*)(labels.data);
    int size = labels.rows * labels.cols;
    for (int i = 0; i &lt; size; i++)
    {
        int label = *ptrLabels++;
        ImageData* data = descriptorsMetadata[i];
        data-&gt;bowFeatures.at&lt;float&gt;(label)++;
    }
}
</code></pre>

<p>We use OpenCV <code>k-means</code> function to obtain k centroids (where k is the size of our network input layer, since the size of our histogram must be compatible with it), stored in the <code>vocabulary</code> variable. We also pass an additional parameter, <code>labels</code>, indicating the index of the nearest cluster for each descriptor, so we don&rsquo;t need to computer it twice. Now, iterating over each element of <code>labels</code>, we fill our histograms, the <code>bowFeatures</code> field of our <code>ImageData</code> struct. The strategy of filling the <code>descriptorsMetadata</code> to make its number of elements as the number of rows of <code>descriptorsSet</code> seemed to be very convenient here, as we can directly access the histogram associated to each descriptor.</p>

<h2>Training the neural network</h2>

<p>Now that we have the histogram of visual words for each image, we can finally supply them to our neural network. But, before that, we need to tell to our neural network the expected output for each image. The reason for that is simple: A neural network, or more precisely, the variation of neural network that we are interested in using, called <a href="https://en.wikipedia.org/wiki/Multilayer_perceptron"><strong>Multilayer perceptron</strong></a>, is a <strong>supervised learning algorithm</strong>. A supervised learning algorithm is one that tries to estimate a function H(x) (called <strong>hypothesis function</strong>) that correctly maps inputs to outputs (for instance, we are considering as input the images and as output the class associated to each image - cat or dog).</p>

<p>So we need to supply the class name associated to each image (or, more precisely, to each histogram of visual words) in order to enable it to &ldquo;learn&rdquo; the pattern. However, a neural network doesn&rsquo;t understand categorical data. It works by showing numbers in the input layer and numbers in the output layer, and then it will try to adjust its weights in order that a function (called <strong>activation function</strong>) applied to the input numbers results in the output numbers. This process is shown in the image below.</p>

<p style="text-align:center;"><img src="/images/posts/ann_3.gif" alt="" /></p>

<p>Since the activation function generally outputs values between 0 and 1, it&rsquo;s usual to encode the classes as a sequence of zeros where only one bit is set to one. This bit is different for each class. For example, consider the example of number of classes = 4. We would then have four codifications:</p>

<p>Class A = 1000<br>
Class B = 0100<br>
Class C = 0010<br>
Class D = 0001<br></p>

<p>As we only have two classes, our codification will be:</p>

<p>Cat = 10<br>
Dog = 01<br></p>

<pre><code>int main()
{
    ...
    // Filling matrixes to be used by the neural network
    std::cout &lt;&lt; "Preparing neural network..." &lt;&lt; std::endl;
    cv::Mat trainSamples;
    cv::Mat trainResponses;
    std::set&lt;ImageData*&gt; uniqueMetadata(descriptorsMetadata.begin(), descriptorsMetadata.end());
    for (auto it = uniqueMetadata.begin(); it != uniqueMetadata.end(); )
    {
        ImageData* data = *it;
        cv::Mat normalizedHist;
        cv::normalize(data-&gt;bowFeatures, normalizedHist, 0, data-&gt;bowFeatures.rows, cv::NORM_MINMAX, -1, cv::Mat());
        trainSamples.push_back(normalizedHist);
        trainResponses.push_back(getClassCode(classes, data-&gt;classname));
        delete *it; // clear memory
        it++;
    }
    descriptorsMetadata.clear();
}
</code></pre>

<p>Notice the use of the <code>getClassCode</code>. It&rsquo;s a function that turns a class name into its binary codification. Also, pay attention to the <code>cv::normalize</code> function. We normalize the histogram of visual words in order to remove the bias of number of descriptors.</p>

<pre><code>/**
 * Transform a class name into an id
 */
int getClassId(const std::set&lt;std::string&gt;&amp; classes, const std::string&amp; classname)
{
    int index = 0;
    for (auto it = classes.begin(); it != classes.end(); ++it)
    {
        if (*it == classname) break;
        ++index;
    }
    return index;
}

/**
 * Get a binary code associated to a class
 */
cv::Mat getClassCode(const std::set&lt;std::string&gt;&amp; classes, const std::string&amp; classname)
{
    cv::Mat code = cv::Mat::zeros(cv::Size((int)classes.size(), 1), CV_32F);
    int index = getClassId(classes, classname);
    code.at&lt;float&gt;(index) = 1;
    return code;
}
</code></pre>

<p>And now we have the inputs and outputs for our neural network! We are finally able to train it!</p>

<pre><code>/**
 * Get a trained neural network according to some inputs and outputs
 */
cv::Ptr&lt;cv::ml::ANN_MLP&gt; getTrainedNeuralNetwork(const cv::Mat&amp; trainSamples, const cv::Mat&amp; trainResponses)
{
    int networkInputSize = trainSamples.cols;
    int networkOutputSize = trainResponses.cols;
    cv::Ptr&lt;cv::ml::ANN_MLP&gt; mlp = cv::ml::ANN_MLP::create();
    std::vector&lt;int&gt; layerSizes = { networkInputSize, networkInputSize / 2,
        networkOutputSize };
    mlp-&gt;setLayerSizes(layerSizes);
    mlp-&gt;setActivationFunction(cv::ml::ANN_MLP::SIGMOID_SYM);
    mlp-&gt;train(trainSamples, cv::ml::ROW_SAMPLE, trainResponses);
    return mlp;
}

int main()
{
    ...
    // Training neural network
    std::cout &lt;&lt; "Training neural network..." &lt;&lt; std::endl;
    start = cv::getTickCount();
    cv::Ptr&lt;cv::ml::ANN_MLP&gt; mlp = getTrainedNeuralNetwork(networkInputSize, 
        trainSamples, trainResponses);
    std::cout &lt;&lt; "Time elapsed in minutes: " &lt;&lt; ((double)cv::getTickCount() - start) / cv::getTickFrequency() / 60.0 &lt;&lt; std::endl;

    // We can clear memory now 
    trainSamples.release();
    trainResponses.release();
}
</code></pre>

<p>The <code>getTrainedNeuralNetwork</code> function expects to receive as input the size of training samples and training outputs. Inside the function, I first set two variables: <code>networkInputSize</code>, that is the number of columns (features) of our training samples and <code>networkOutputSize</code>, that is the number of columns of our training outputs. I then set <code>layerSizes</code>, that defines the number of layers and number of nodes for each layer of our network. For instance, I&rsquo;m creating a network that only have one hidden layer (with size <code>networkInputSize / 2</code>), since I think it&rsquo;ll be enough for our task. If you want improved accuracy, we can increase it, at cost of performance.</p>

<h2>Evaluating our network</h2>

<p>And now the training step is DONE! Let&rsquo;s use our trained neural network to evaluate our test samples and measure how good it is. First, let&rsquo;s train a FLANN model from the vocabulary, so we can calculate the histogram of visual words for each test sample much faster:</p>

<pre><code>int main()
{
    ...

    // Train FLANN 
    std::cout &lt;&lt; "Training FLANN..." &lt;&lt; std::endl;
    start = cv::getTickCount();
    cv::FlannBasedMatcher flann;
    flann.add(vocabulary);
    flann.train();
    std::cout &lt;&lt; "Time elapsed in minutes: " &lt;&lt; ((double)cv::getTickCount() - start) / cv::getTickFrequency() / 60.0 &lt;&lt; std::endl;
}
</code></pre>

<p>Now let&rsquo;s read the test samples:</p>

<pre><code>int main()
{
    ...
    // Reading test set 
    std::cout &lt;&lt; "Reading test set..." &lt;&lt; std::endl;
    start = cv::getTickCount();
    cv::Mat testSamples;
    std::vector&lt;int&gt; testOutputExpected;
    readImages(files.begin() + (size_t)(files.size() * trainSplitRatio), files.end(),
        [&amp;](const std::string&amp; classname, const cv::Mat&amp; descriptors) {
        // Get histogram of visual words using bag of words technique
        cv::Mat bowFeatures = getBOWFeatures(flann, descriptors, networkInputSize);
        cv::normalize(bowFeatures, bowFeatures, 0, bowFeatures.rows, cv::NORM_MINMAX, -1, cv::Mat());
        testSamples.push_back(bowFeatures);
        testOutputExpected.push_back(getClassId(classes, classname));
    });
    std::cout &lt;&lt; "Time elapsed in minutes: " &lt;&lt; ((double)cv::getTickCount() - start) / cv::getTickFrequency() / 60.0 &lt;&lt; std::endl;
}
</code></pre>

<p>We instanciated two variables: <code>testSamples</code> (set of histogram of visual words for each test samples) and <code>testOutputExpected</code> (the output expected for each test sample. We are using a number that correspond to the id of the class, obtained through the <code>getClassId</code> previously defined). We then get the Bag of Words features through the <code>getBOWFeatures</code> function and normalize it. What we still didn&rsquo;t define is the <code>getBOWFeatures</code> function, that turns a set of local KAZE features into a histogram of visual words. Let&rsquo;s do it:</p>

<pre><code>/**
 * Turn local features into a single bag of words histogram of 
 * of visual words (a.k.a., bag of words features)
 */
cv::Mat getBOWFeatures(cv::FlannBasedMatcher&amp; flann, const cv::Mat&amp; descriptors,
    int vocabularySize)
{
    cv::Mat outputArray = cv::Mat::zeros(cv::Size(vocabularySize, 1), CV_32F);
    std::vector&lt;cv::DMatch&gt; matches;
    flann.match(descriptors, matches);
    for (size_t j = 0; j &lt; matches.size(); j++)
    {
        int visualWord = matches[j].trainIdx;
        outputArray.at&lt;float&gt;(visualWord)++;
    }
    return outputArray;
}
</code></pre>

<p>It uses the FLANN <code>match</code> method to calculate the nearest visual word for each descriptor. It then fill a histogram with the number of occurrences for each visual word. Pretty simple, right?</p>

<p>Now that we have the inputs and outputs for the test samples, let&rsquo;s calculate a <a href="https://en.wikipedia.org/wiki/Confusion_matrix"><strong>confusion matrix</strong></a>.</p>

<pre><code>
/**
 * Receives a column matrix contained the probabilities associated to 
 * each class and returns the id of column which contains the highest
 * probability
 */
int getPredictedClass(const cv::Mat&amp; predictions)
{
    float maxPrediction = predictions.at&lt;float&gt;(0);
    float maxPredictionIndex = 0;
    const float* ptrPredictions = predictions.ptr&lt;float&gt;(0);
    for (int i = 0; i &lt; predictions.cols; i++)
    {
        float prediction = *ptrPredictions++;
        if (prediction &gt; maxPrediction)
        {
            maxPrediction = prediction;
            maxPredictionIndex = i;
        }
    }
    return maxPredictionIndex;
}

/**
 * Get a confusion matrix from a set of test samples and their expected
 * outputs
 */
std::vector&lt;std::vector&lt;int&gt; &gt; getConfusionMatrix(cv::Ptr&lt;cv::ml::ANN_MLP&gt; mlp, 
    const cv::Mat&amp; testSamples, const std::vector&lt;int&gt;&amp; testOutputExpected)
{
    cv::Mat testOutput;
    mlp-&gt;predict(testSamples, testOutput);
    std::vector&lt;std::vector&lt;int&gt; &gt; confusionMatrix(2, std::vector&lt;int&gt;(2));
    for (int i = 0; i &lt; testOutput.rows; i++)
    {
        int predictedClass = getPredictedClass(testOutput.row(i));
        int expectedClass = testOutputExpected.at(i);
        confusionMatrix[expectedClass][predictedClass]++;
    }
    return confusionMatrix;
}

/**
 * Print a confusion matrix on screen
 */
void printConfusionMatrix(const std::vector&lt;std::vector&lt;int&gt; &gt;&amp; confusionMatrix,
    const std::set&lt;std::string&gt;&amp; classes)
{
    for (auto it = classes.begin(); it != classes.end(); ++it)
    {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    for (size_t i = 0; i &lt; confusionMatrix.size(); i++)
    {
        for (size_t j = 0; j &lt; confusionMatrix[i].size(); j++)
        {
            std::cout &lt;&lt; confusionMatrix[i][j] &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }
}

/**
 * Get the accuracy for a model (i.e., percentage of correctly predicted
 * test samples)
 */
float getAccuracy(const std::vector&lt;std::vector&lt;int&gt; &gt;&amp; confusionMatrix)
{
    int hits = 0;
    int total = 0;
    for (size_t i = 0; i &lt; confusionMatrix.size(); i++)
    {
        for (size_t j = 0; j &lt; confusionMatrix.at(i).size(); j++)
        {
            if (i == j) hits += confusionMatrix.at(i).at(j);
            total += confusionMatrix.at(i).at(j);
        }
    }
    return hits / (float)total;
}

int main()
{
    ...
    // Get confusion matrix of the test set
    std::vector&lt;std::vector&lt;int&gt; &gt; confusionMatrix = getConfusionMatrix(mlp, 
        testSamples, testOutputExpected);

    // Get accuracy of our model
    std::cout &lt;&lt; "Confusion matrix: " &lt;&lt; std::endl;
    printConfusionMatrix(confusionMatrix, classes);
    std::cout &lt;&lt; "Accuracy: " &lt;&lt; getAccuracy(confusionMatrix) &lt;&lt; std::endl;
}
</code></pre>

<p>OK, a lot happened here. Let&rsquo;s check it step by step. First, in the <code>getConfusionMatrix</code>, I use the MLP <code>predict</code> method to predict the class for each test sample. It returns a matrix with the same number of columns as our number of classes, where on each column lies a &ldquo;probability&rdquo; of the sample belong to class corresponding to that column. We use than a function called <code>getPredictedClass</code>, which is called over each row of the output of <code>predict</code> method and return the column index with highest &ldquo;probability&rdquo;. Now that we have the predicted and expected classes, we can construct our confusion matrix by simplying incrementing the index composed by the tuple (expected, predicted).</p>

<p>In possess of the confusion matrix, we can easily calculate the <strong>accuracy</strong>, that is the ratio of correctly predicted samples, by simplying summing the diagonal of our confusion matrix (number of correct predictions) and diving by the sum of our cells of our confusion matrix (number of test samples).</p>

<p style="text-align:center;"> <img src="/images/posts/ann_4.png" alt="" /></p>

<h2>Saving models</h2>

<p>Finally, let&rsquo;s save our models, so we can use it later on a production environment:</p>

<pre><code>/**
 * Save our obtained models (neural network, bag of words vocabulary
 * and class names) to use it later
 */
void saveModels(cv::Ptr&lt;cv::ml::ANN_MLP&gt; mlp, const cv::Mat&amp; vocabulary,
    const std::set&lt;std::string&gt;&amp; classes)
{
    mlp-&gt;save("mlp.yaml");
    cv::FileStorage fs("vocabulary.yaml", cv::FileStorage::WRITE);
    fs &lt;&lt; "vocabulary" &lt;&lt; vocabulary;
    fs.release();   
    std::ofstream classesOutput("classes.txt");
    for (auto it = classes.begin(); it != classes.end(); ++it)
    {
        classesOutput &lt;&lt; getClassId(classes, *it) &lt;&lt; "\t" &lt;&lt; *it &lt;&lt; std::endl; 
    }
    classesOutput.close();
}

int main()
{
    ...

    // Save models
    std::cout &lt;&lt; "Saving models..." &lt;&lt; std::endl;
    saveModels(mlp, vocabulary, classes);

    return 0;
}
</code></pre>

<p>The MLP object that its own saving function called <code>save</code> (it also has a <code>load</code> method that can later be used to load a trained neural network from a file). We save the vocabulary (since we need it in order to convert the local features into a histogram of visual words) into a file named &ldquo;vocabulary.yaml&rdquo;. And, finally, we also save the class names associated to each id (so we can map the output of neural network to a name). That&rsquo;s it! The full code can be found below.</p>

<center><input id="spoiler" type="button" value="See source code" onclick="toggle_visibility('code');"></center>


<div id="code">
<figure class='code'><figcaption><span>eye_detector.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;algorithm&gt;</span>
</span><span class='line'><span class="cp">#include &lt;functional&gt;</span>
</span><span class='line'><span class="cp">#include &lt;map&gt;</span>
</span><span class='line'><span class="cp">#include &lt;set&gt;</span>
</span><span class='line'><span class="cp">#include &lt;fstream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;opencv2/core/core.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/highgui/highgui.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/features2d/features2d.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/ml/ml.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;boost/filesystem.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">namespace</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">filesystem</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">vec_iter</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">ImageData</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">classname</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">bowFeatures</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Get all files in directory (not recursive)</span>
</span><span class='line'><span class="cm"> * @param directory Directory where the files are contained</span>
</span><span class='line'><span class="cm"> * @return A list containing the file name of all files inside given directory</span>
</span><span class='line'><span class="cm"> **/</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">getFilesInDirectory</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">directory</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">files</span><span class="p">;</span>
</span><span class='line'>    <span class="n">fs</span><span class="o">::</span><span class="n">path</span> <span class="n">root</span><span class="p">(</span><span class="n">directory</span><span class="p">);</span>
</span><span class='line'>    <span class="n">fs</span><span class="o">::</span><span class="n">directory_iterator</span> <span class="n">it_end</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">fs</span><span class="o">::</span><span class="n">directory_iterator</span> <span class="n">it</span><span class="p">(</span><span class="n">root</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">fs</span><span class="o">::</span><span class="n">is_regular_file</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">()))</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">files</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">().</span><span class="n">string</span><span class="p">());</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">files</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Extract the class name from a file name </span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getClassName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">filename</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">filename</span><span class="p">.</span><span class="n">find_last_of</span><span class="p">(</span><span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Extract local features for an image</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">getDescriptors</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">KAZE</span><span class="o">&gt;</span> <span class="n">kaze</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">KAZE</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">KeyPoint</span><span class="o">&gt;</span> <span class="n">keypoints</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">descriptors</span><span class="p">;</span>
</span><span class='line'>    <span class="n">kaze</span><span class="o">-&gt;</span><span class="n">detectAndCompute</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">noArray</span><span class="p">(),</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">descriptors</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Read images from a list of file names and returns, for each read image,</span>
</span><span class='line'><span class="cm"> * its class name and its local descriptors</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span> <span class="n">readImages</span><span class="p">(</span><span class="n">vec_iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">vec_iter</span> <span class="n">end</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">callback</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Reading image &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">img</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;WARNING: Could not read image.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">classname</span> <span class="o">=</span> <span class="n">getClassName</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">descriptors</span> <span class="o">=</span> <span class="n">getDescriptors</span><span class="p">(</span><span class="n">img</span><span class="p">);</span>
</span><span class='line'>        <span class="n">callback</span><span class="p">(</span><span class="n">classname</span><span class="p">,</span> <span class="n">descriptors</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Transform a class name into an id</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">int</span> <span class="n">getClassId</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">classes</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">classname</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">classes</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">classes</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span> <span class="o">==</span> <span class="n">classname</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="o">++</span><span class="n">index</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Get a binary code associated to a class</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">getClassCode</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">classes</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">classname</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">code</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">classes</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">CV_32F</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">getClassId</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">classname</span><span class="p">);</span>
</span><span class='line'>    <span class="n">code</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">code</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Turn local features into a single bag of words histogram of </span>
</span><span class='line'><span class="cm"> * of visual words (a.k.a., bag of words features)</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">getBOWFeatures</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">FlannBasedMatcher</span><span class="o">&amp;</span> <span class="n">flann</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">descriptors</span><span class="p">,</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">vocabularySize</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">outputArray</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">vocabularySize</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">CV_32F</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">DMatch</span><span class="o">&gt;</span> <span class="n">matches</span><span class="p">;</span>
</span><span class='line'>    <span class="n">flann</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">descriptors</span><span class="p">,</span> <span class="n">matches</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matches</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">visualWord</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">trainIdx</span><span class="p">;</span>
</span><span class='line'>        <span class="n">outputArray</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">visualWord</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">outputArray</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Get a trained neural network according to some inputs and outputs</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">&gt;</span> <span class="n">getTrainedNeuralNetwork</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">trainSamples</span><span class="p">,</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">trainResponses</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">networkInputSize</span> <span class="o">=</span> <span class="n">trainSamples</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">networkOutputSize</span> <span class="o">=</span> <span class="n">trainResponses</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">&gt;</span> <span class="n">mlp</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">layerSizes</span> <span class="o">=</span> <span class="p">{</span> <span class="n">networkInputSize</span><span class="p">,</span> <span class="n">networkInputSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
</span><span class='line'>        <span class="n">networkOutputSize</span> <span class="p">};</span>
</span><span class='line'>    <span class="n">mlp</span><span class="o">-&gt;</span><span class="n">setLayerSizes</span><span class="p">(</span><span class="n">layerSizes</span><span class="p">);</span>
</span><span class='line'>    <span class="n">mlp</span><span class="o">-&gt;</span><span class="n">setActivationFunction</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">::</span><span class="n">SIGMOID_SYM</span><span class="p">);</span>
</span><span class='line'>    <span class="n">mlp</span><span class="o">-&gt;</span><span class="n">train</span><span class="p">(</span><span class="n">trainSamples</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ROW_SAMPLE</span><span class="p">,</span> <span class="n">trainResponses</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">mlp</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Receives a column matrix contained the probabilities associated to </span>
</span><span class='line'><span class="cm"> * each class and returns the id of column which contains the highest</span>
</span><span class='line'><span class="cm"> * probability</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">int</span> <span class="n">getPredictedClass</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">predictions</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">maxPrediction</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">maxPredictionIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">ptrPredictions</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">predictions</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">float</span> <span class="n">prediction</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptrPredictions</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">prediction</span> <span class="o">&gt;</span> <span class="n">maxPrediction</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">maxPrediction</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">;</span>
</span><span class='line'>            <span class="n">maxPredictionIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">maxPredictionIndex</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Get a confusion matrix from a set of test samples and their expected</span>
</span><span class='line'><span class="cm"> * outputs</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">getConfusionMatrix</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">&gt;</span> <span class="n">mlp</span><span class="p">,</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">testSamples</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">testOutputExpected</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">testOutput</span><span class="p">;</span>
</span><span class='line'>    <span class="n">mlp</span><span class="o">-&gt;</span><span class="n">predict</span><span class="p">(</span><span class="n">testSamples</span><span class="p">,</span> <span class="n">testOutput</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">confusionMatrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testOutput</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">predictedClass</span> <span class="o">=</span> <span class="n">getPredictedClass</span><span class="p">(</span><span class="n">testOutput</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">expectedClass</span> <span class="o">=</span> <span class="n">testOutputExpected</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>        <span class="n">confusionMatrix</span><span class="p">[</span><span class="n">expectedClass</span><span class="p">][</span><span class="n">predictedClass</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">confusionMatrix</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Print a confusion matrix on screen</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span> <span class="n">printConfusionMatrix</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">confusionMatrix</span><span class="p">,</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">classes</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">classes</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">classes</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">confusionMatrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">confusionMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">confusionMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Get the accuracy for a model (i.e., percentage of correctly predicted</span>
</span><span class='line'><span class="cm"> * test samples)</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">float</span> <span class="n">getAccuracy</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">confusionMatrix</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">hits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">confusionMatrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">confusionMatrix</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="n">hits</span> <span class="o">+=</span> <span class="n">confusionMatrix</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">at</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'>            <span class="n">total</span> <span class="o">+=</span> <span class="n">confusionMatrix</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">at</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">hits</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">total</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Save our obtained models (neural network, bag of words vocabulary</span>
</span><span class='line'><span class="cm"> * and class names) to use it later</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span> <span class="n">saveModels</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">&gt;</span> <span class="n">mlp</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">vocabulary</span><span class="p">,</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">classes</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">mlp</span><span class="o">-&gt;</span><span class="n">save</span><span class="p">(</span><span class="s">&quot;mlp.yaml&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">FileStorage</span> <span class="n">fs</span><span class="p">(</span><span class="s">&quot;vocabulary.yaml&quot;</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">FileStorage</span><span class="o">::</span><span class="n">WRITE</span><span class="p">);</span>
</span><span class='line'>    <span class="n">fs</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;vocabulary&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">vocabulary</span><span class="p">;</span>
</span><span class='line'>    <span class="n">fs</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">classesOutput</span><span class="p">(</span><span class="s">&quot;classes.txt&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">classes</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">classes</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">classesOutput</span> <span class="o">&lt;&lt;</span> <span class="n">getClassId</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">classesOutput</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Usage: &lt;IMAGES_DIRECTORY&gt;  &lt;NETWORK_INPUT_LAYER_SIZE&gt; &lt;TRAIN_SPLIT_RATIO&gt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">imagesDir</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">networkInputSize</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">trainSplitRatio</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Reading training set...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">double</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">files</span> <span class="o">=</span> <span class="n">getFilesInDirectory</span><span class="p">(</span><span class="n">imagesDir</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">random_shuffle</span><span class="p">(</span><span class="n">files</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">files</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">descriptorsSet</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ImageData</span><span class="o">*&gt;</span> <span class="n">descriptorsMetadata</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">classes</span><span class="p">;</span>
</span><span class='line'>    <span class="n">readImages</span><span class="p">(</span><span class="n">files</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">files</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">files</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="n">trainSplitRatio</span><span class="p">),</span>
</span><span class='line'>        <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">classname</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">descriptors</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Append to the set of classes</span>
</span><span class='line'>        <span class="n">classes</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">classname</span><span class="p">);</span>
</span><span class='line'>        <span class="c1">// Append to the list of descriptors</span>
</span><span class='line'>        <span class="n">descriptorsSet</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">descriptors</span><span class="p">);</span>
</span><span class='line'>        <span class="c1">// Append metadata to each extracted feature</span>
</span><span class='line'>        <span class="n">ImageData</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ImageData</span><span class="p">;</span>
</span><span class='line'>        <span class="n">data</span><span class="o">-&gt;</span><span class="n">classname</span> <span class="o">=</span> <span class="n">classname</span><span class="p">;</span>
</span><span class='line'>        <span class="n">data</span><span class="o">-&gt;</span><span class="n">bowFeatures</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">networkInputSize</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">CV_32F</span><span class="p">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">descriptors</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">descriptorsMetadata</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Time elapsed in minutes: &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickFrequency</span><span class="p">()</span> <span class="o">/</span> <span class="mf">60.0</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Creating vocabulary...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">();</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">labels</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">vocabulary</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// Use k-means to find k centroids (the words of our vocabulary)</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">kmeans</span><span class="p">(</span><span class="n">descriptorsSet</span><span class="p">,</span> <span class="n">networkInputSize</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">TermCriteria</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">TermCriteria</span><span class="o">::</span><span class="n">EPS</span> <span class="o">+</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">TermCriteria</span><span class="o">::</span><span class="n">MAX_ITER</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">KMEANS_PP_CENTERS</span><span class="p">,</span> <span class="n">vocabulary</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// No need to keep it on memory anymore</span>
</span><span class='line'>    <span class="n">descriptorsSet</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Time elapsed in minutes: &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickFrequency</span><span class="p">()</span> <span class="o">/</span> <span class="mf">60.0</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Convert a set of local features for each image in a single descriptors</span>
</span><span class='line'>    <span class="c1">// using the bag of words technique</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Getting histograms of visual words...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span><span class="o">*</span> <span class="n">ptrLabels</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">labels</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">labels</span><span class="p">.</span><span class="n">rows</span> <span class="o">*</span> <span class="n">labels</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">label</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptrLabels</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="n">ImageData</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="n">descriptorsMetadata</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="n">data</span><span class="o">-&gt;</span><span class="n">bowFeatures</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Filling matrixes to be used by the neural network</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Preparing neural network...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">trainSamples</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">trainResponses</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">ImageData</span><span class="o">*&gt;</span> <span class="n">uniqueMetadata</span><span class="p">(</span><span class="n">descriptorsMetadata</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">descriptorsMetadata</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">uniqueMetadata</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">uniqueMetadata</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">ImageData</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">normalizedHist</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">bowFeatures</span><span class="p">,</span> <span class="n">normalizedHist</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">bowFeatures</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">NORM_MINMAX</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">());</span>
</span><span class='line'>        <span class="n">trainSamples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">normalizedHist</span><span class="p">);</span>
</span><span class='line'>        <span class="n">trainResponses</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getClassCode</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">classname</span><span class="p">));</span>
</span><span class='line'>        <span class="k">delete</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span> <span class="c1">// clear memory</span>
</span><span class='line'>        <span class="n">it</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">descriptorsMetadata</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Training neural network</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Training neural network...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">start</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">();</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">&gt;</span> <span class="n">mlp</span> <span class="o">=</span> <span class="n">getTrainedNeuralNetwork</span><span class="p">(</span><span class="n">trainSamples</span><span class="p">,</span> <span class="n">trainResponses</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Time elapsed in minutes: &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickFrequency</span><span class="p">()</span> <span class="o">/</span> <span class="mf">60.0</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// We can clear memory now </span>
</span><span class='line'>    <span class="n">trainSamples</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span><span class='line'>    <span class="n">trainResponses</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Train FLANN </span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Training FLANN...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">start</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">();</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">FlannBasedMatcher</span> <span class="n">flann</span><span class="p">;</span>
</span><span class='line'>    <span class="n">flann</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">vocabulary</span><span class="p">);</span>
</span><span class='line'>    <span class="n">flann</span><span class="p">.</span><span class="n">train</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Time elapsed in minutes: &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickFrequency</span><span class="p">()</span> <span class="o">/</span> <span class="mf">60.0</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Reading test set </span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Reading test set...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">start</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">();</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">testSamples</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">testOutputExpected</span><span class="p">;</span>
</span><span class='line'>    <span class="n">readImages</span><span class="p">(</span><span class="n">files</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">files</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="n">trainSplitRatio</span><span class="p">),</span> <span class="n">files</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span><span class='line'>        <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">classname</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">descriptors</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Get histogram of visual words using bag of words technique</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">bowFeatures</span> <span class="o">=</span> <span class="n">getBOWFeatures</span><span class="p">(</span><span class="n">flann</span><span class="p">,</span> <span class="n">descriptors</span><span class="p">,</span> <span class="n">networkInputSize</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">bowFeatures</span><span class="p">,</span> <span class="n">bowFeatures</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bowFeatures</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">NORM_MINMAX</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">());</span>
</span><span class='line'>        <span class="n">testSamples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">bowFeatures</span><span class="p">);</span>
</span><span class='line'>        <span class="n">testOutputExpected</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getClassId</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">classname</span><span class="p">));</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Time elapsed in minutes: &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickFrequency</span><span class="p">()</span> <span class="o">/</span> <span class="mf">60.0</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Get confusion matrix of the test set</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">confusionMatrix</span> <span class="o">=</span> <span class="n">getConfusionMatrix</span><span class="p">(</span><span class="n">mlp</span><span class="p">,</span>
</span><span class='line'>        <span class="n">testSamples</span><span class="p">,</span> <span class="n">testOutputExpected</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Get accuracy of our model</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Confusion matrix: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">printConfusionMatrix</span><span class="p">(</span><span class="n">confusionMatrix</span><span class="p">,</span> <span class="n">classes</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Accuracy: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">getAccuracy</span><span class="p">(</span><span class="n">confusionMatrix</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Save models</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Saving models...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">saveModels</span><span class="p">(</span><span class="n">mlp</span><span class="p">,</span> <span class="n">vocabulary</span><span class="p">,</span> <span class="n">classes</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</div>


<p>Compile it by calling:
<code>Bash
g++ opencv_ann.cpp -std=c++0x  -I/usr/local/include/opencv -I/usr/local/include/boost -I/usr/local/include -L/usr/local/lib -lopencv_shape -lopencv_stitching -lopencv_objdetect -lopencv_superres -lopencv_videostab -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs -lopencv_video -lopencv_photo -lopencv_ml -lopencv_imgproc -lopencv_flann -lopencv_core -lopencv_hal -lboost_filesystem -lboost_system -o mlp
</code></p>

<p>For instance, here&rsquo;s the result I got from the Kaggle&rsquo;s training set (using networkInputSize = 512, trainSplitRatio = 0.7)
<code>C++
Confusion matrix:
cat dog
2669 1097
1053 2681
Accuracy: 0.713333
</code>
Not bad! Not bad at all, considering the difficulty of some images! ;)</p>

<p style="text-align:center;"><img src="/images/posts/ann_dog.jpg" alt="" /> <img src="/images/posts/ann_cat.jpg" alt="" /></p>

<p>If you are interested in knowing how the server used to present the live demo in the beginning of this tutorial looks like, you can take a look at the source code below.</p>

<center><input id="spoiler2" type="button" value="See source code" onclick="toggle_visibility('code2');"></center>


<div id="code2">
<figure class='code'><figcaption><span>demo.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
</pre></td><td class='code'><pre><code class='C++'><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;set&gt;</span>
</span><span class='line'><span class="cp">#include &lt;sstream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;fstream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;cstdlib&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;algorithm&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;boost/bind.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;boost/asio.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;opencv2/core/core.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/highgui/highgui.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/features2d/features2d.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/ml/ml.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">Context</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">vocabulary</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">FlannBasedMatcher</span> <span class="n">flann</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">classes</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">&gt;</span> <span class="n">mlp</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Extract local features for an image</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">getDescriptors</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">KAZE</span><span class="o">&gt;</span> <span class="n">kaze</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">KAZE</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">KeyPoint</span><span class="o">&gt;</span> <span class="n">keypoints</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">descriptors</span><span class="p">;</span>
</span><span class='line'>    <span class="n">kaze</span><span class="o">-&gt;</span><span class="n">detectAndCompute</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">noArray</span><span class="p">(),</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">descriptors</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Get a histogram of visual words for an image</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">getBOWFeatures</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">FlannBasedMatcher</span><span class="o">&amp;</span> <span class="n">flann</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">vocabularySize</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">descriptors</span> <span class="o">=</span> <span class="n">getDescriptors</span><span class="p">(</span><span class="n">img</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">outputArray</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">vocabularySize</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">CV_32F</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">DMatch</span><span class="o">&gt;</span> <span class="n">matches</span><span class="p">;</span>
</span><span class='line'>    <span class="n">flann</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">descriptors</span><span class="p">,</span> <span class="n">matches</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matches</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">visualWord</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">trainIdx</span><span class="p">;</span>
</span><span class='line'>        <span class="n">outputArray</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">visualWord</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">outputArray</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Receives a column matrix contained the probabilities associated to </span>
</span><span class='line'><span class="cm"> * each class and returns the id of column which contains the highest</span>
</span><span class='line'><span class="cm"> * probability</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">int</span> <span class="n">getPredictedClass</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">predictions</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">maxPrediction</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">maxPredictionIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">ptrPredictions</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">predictions</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">float</span> <span class="n">prediction</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptrPredictions</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">prediction</span> <span class="o">&gt;</span> <span class="n">maxPrediction</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">maxPrediction</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">;</span>
</span><span class='line'>            <span class="n">maxPredictionIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">maxPredictionIndex</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Get the predicted class for a sample</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">int</span> <span class="n">getClass</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">bowFeatures</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">&gt;</span> <span class="n">mlp</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">output</span><span class="p">;</span>
</span><span class='line'>    <span class="n">mlp</span><span class="o">-&gt;</span><span class="n">predict</span><span class="p">(</span><span class="n">bowFeatures</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">getPredictedClass</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">session</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">session</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">io_service</span><span class="p">,</span> <span class="n">Context</span><span class="o">*</span> <span class="n">context</span><span class="p">)</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">socket_</span><span class="p">(</span><span class="n">io_service</span><span class="p">),</span> <span class="n">context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">tcp</span><span class="o">::</span><span class="n">socket</span><span class="o">&amp;</span> <span class="n">socket</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">socket_</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="n">start</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">socket_</span><span class="p">.</span><span class="n">async_read_some</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">data_</span><span class="p">,</span> <span class="n">max_length</span><span class="p">),</span>
</span><span class='line'>            <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">::</span><span class="n">handle_read</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span>
</span><span class='line'>              <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">error</span><span class="p">,</span>
</span><span class='line'>              <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">bytes_transferred</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Context</span><span class="o">*</span> <span class="n">context</span><span class="p">;</span>
</span><span class='line'>    <span class="n">tcp</span><span class="o">::</span><span class="n">socket</span> <span class="n">socket_</span><span class="p">;</span>
</span><span class='line'>    <span class="k">enum</span> <span class="p">{</span> <span class="n">max_length</span> <span class="o">=</span> <span class="mi">1024</span> <span class="p">};</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="n">max_length</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">handle_read</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">,</span>
</span><span class='line'>      <span class="kt">size_t</span> <span class="n">bytes_transferred</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>            <span class="c1">// Reading image</span>
</span><span class='line'>            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename</span><span class="p">(</span><span class="n">data_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">data_</span><span class="p">,</span> <span class="n">data_</span> <span class="o">+</span> <span class="n">bytes_transferred</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">img</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="c1">// Processing image</span>
</span><span class='line'>                <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">bowFeatures</span> <span class="o">=</span> <span class="n">getBOWFeatures</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">flann</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">vocabulary</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span>
</span><span class='line'>                <span class="n">cv</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">bowFeatures</span><span class="p">,</span> <span class="n">bowFeatures</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bowFeatures</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">NORM_MINMAX</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">());</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">predictedClass</span> <span class="o">=</span> <span class="n">getClass</span><span class="p">(</span><span class="n">bowFeatures</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">mlp</span><span class="p">);</span>
</span><span class='line'>                <span class="n">result</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">classes</span><span class="p">[</span><span class="n">predictedClass</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;error&quot;</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data_</span><span class="p">));</span>
</span><span class='line'>            <span class="n">strcpy</span><span class="p">(</span><span class="n">data_</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</span><span class='line'>            <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">async_write</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span>
</span><span class='line'>              <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">data_</span><span class="p">,</span> <span class="n">bytes_transferred</span><span class="p">),</span>
</span><span class='line'>              <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">::</span><span class="n">handle_write</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span>
</span><span class='line'>                <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">error</span><span class="p">));</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">handle_write</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">socket_</span><span class="p">.</span><span class="n">async_read_some</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">data_</span><span class="p">,</span> <span class="n">max_length</span><span class="p">),</span>
</span><span class='line'>              <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">::</span><span class="n">handle_read</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span>
</span><span class='line'>                <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">error</span><span class="p">,</span>
</span><span class='line'>                <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">bytes_transferred</span><span class="p">));</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">server</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">server</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">io_service</span><span class="p">,</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="n">Context</span><span class="o">*</span> <span class="n">context</span><span class="p">)</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">io_service_</span><span class="p">(</span><span class="n">io_service</span><span class="p">),</span>
</span><span class='line'>      <span class="n">acceptor_</span><span class="p">(</span><span class="n">io_service</span><span class="p">,</span> <span class="n">tcp</span><span class="o">::</span><span class="n">endpoint</span><span class="p">(</span><span class="n">tcp</span><span class="o">::</span><span class="n">v4</span><span class="p">(),</span> <span class="n">port</span><span class="p">)),</span>
</span><span class='line'>      <span class="n">context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">start_accept</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Context</span><span class="o">*</span> <span class="n">context</span><span class="p">;</span>
</span><span class='line'>    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">io_service_</span><span class="p">;</span>
</span><span class='line'>    <span class="n">tcp</span><span class="o">::</span><span class="n">acceptor</span> <span class="n">acceptor_</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">start_accept</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">session</span><span class="o">*</span> <span class="n">new_session</span> <span class="o">=</span> <span class="k">new</span> <span class="n">session</span><span class="p">(</span><span class="n">io_service_</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</span><span class='line'>        <span class="n">acceptor_</span><span class="p">.</span><span class="n">async_accept</span><span class="p">(</span><span class="n">new_session</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">(),</span>
</span><span class='line'>            <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">::</span><span class="n">handle_accept</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">new_session</span><span class="p">,</span>
</span><span class='line'>              <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">error</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">handle_accept</span><span class="p">(</span><span class="n">session</span><span class="o">*</span> <span class="n">new_session</span><span class="p">,</span>
</span><span class='line'>      <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>          <span class="n">new_session</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>          <span class="k">delete</span> <span class="n">new_session</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">start_accept</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Usage: &lt;NEURAL_NETWORK_INPUT_FILENAME&gt; &lt;VOCABULARY_INPUT_FILENAME&gt; &lt;CLASSES_INPUT_FILENAME&gt; &lt;PORT_NUMBER&gt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">neuralNetworkInputFilename</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">vocabularyInputFilename</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">classesInputFilename</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">portNumber</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Loading models...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">double</span> <span class="n">start</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">();</span>
</span><span class='line'>    <span class="c1">// Reading neural network</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">&gt;</span> <span class="n">mlp</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">::</span><span class="n">load</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">ml</span><span class="o">::</span><span class="n">ANN_MLP</span><span class="o">&gt;</span><span class="p">(</span><span class="n">neuralNetworkInputFilename</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// Read vocabulary</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">vocabulary</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">FileStorage</span> <span class="n">fs</span><span class="p">(</span><span class="n">vocabularyInputFilename</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">FileStorage</span><span class="o">::</span><span class="n">READ</span><span class="p">);</span>
</span><span class='line'>    <span class="n">fs</span><span class="p">[</span><span class="s">&quot;vocabulary&quot;</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">vocabulary</span><span class="p">;</span>
</span><span class='line'>    <span class="n">fs</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span><span class='line'>    <span class="c1">// Reading existing classes</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">classes</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">classesInput</span><span class="p">(</span><span class="n">classesInputFilename</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">classesInput</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
</span><span class='line'>        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="n">line</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">classname</span><span class="p">;</span>
</span><span class='line'>        <span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">index</span><span class="p">;</span>
</span><span class='line'>        <span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">classname</span><span class="p">;</span>
</span><span class='line'>        <span class="n">classes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">classname</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Time elapsed in seconds: &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickFrequency</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Train FLANN </span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Training FLANN...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">start</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">();</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">FlannBasedMatcher</span> <span class="n">flann</span><span class="p">;</span>
</span><span class='line'>    <span class="n">flann</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">vocabulary</span><span class="p">);</span>
</span><span class='line'>    <span class="n">flann</span><span class="p">.</span><span class="n">train</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Time elapsed in seconds: &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">cv</span><span class="o">::</span><span class="n">getTickCount</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTickFrequency</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Socket initialization</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Listening to socket on port &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">portNumber</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">try</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">io_service</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Context</span><span class="o">*</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Context</span><span class="p">;</span>
</span><span class='line'>        <span class="n">context</span><span class="o">-&gt;</span><span class="n">vocabulary</span> <span class="o">=</span> <span class="n">vocabulary</span><span class="p">;</span>
</span><span class='line'>        <span class="n">context</span><span class="o">-&gt;</span><span class="n">flann</span> <span class="o">=</span> <span class="n">flann</span><span class="p">;</span>
</span><span class='line'>        <span class="n">context</span><span class="o">-&gt;</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span><span class="p">;</span>
</span><span class='line'>        <span class="n">context</span><span class="o">-&gt;</span><span class="n">mlp</span> <span class="o">=</span> <span class="n">mlp</span><span class="p">;</span>
</span><span class='line'>        <span class="n">server</span> <span class="n">s</span><span class="p">(</span><span class="n">io_service</span><span class="p">,</span> <span class="n">portNumber</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</span><span class='line'>        <span class="n">io_service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
</span><span class='line'>        <span class="k">delete</span> <span class="n">context</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Exception: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</div>


<script>
$(function() {
    $("#code2").hide();
});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Solving the Sliding Puzzle]]></title>
    <link href="http://abner-math.github.io/blog/2015/12/06/solving-the-sliding-puzzle/"/>
    <updated>2015-12-06T17:01:05-03:00</updated>
    <id>http://abner-math.github.io/blog/2015/12/06/solving-the-sliding-puzzle</id>
    <content type="html"><![CDATA[<script src="http://abner-math.github.io/js/sliding-puzzle/minheap.js"></script>


<script src="http://abner-math.github.io/js/sliding-puzzle/sliding-puzzle.js"></script>


<script src="http://abner-math.github.io/js/sliding-puzzle/sliding-puzzle-frontend.js"></script>


<p><link href="http://abner-math.github.io/stylesheets/sliding-puzzle.css" rel="stylesheet" type="text/css"></p>

<p>Sliding puzzle is a game composed by 2<sup>n</sup> - 1 pieces dispersed along a board and a blank space. Those pieces are then shuffled and the objective is to rearrange them back to their original form, where the disposition of pieces is on ascending order, like shown below (go on, it&rsquo;s interactive):</p>

<center>
    <div>
        <div id="container-a-example" class="puzzle"></div>
    </div>
</center>


<p></p>

<script type="text/javascript">
    new PuzzleGUI($("#container-a-example"), 4, 50, 5, 100, 10, Algorithm.AManhattan);
</script>


<p>You can rearrange the pieces &ldquo;moving&rdquo; the blank space across the board. Since you can only move it in four directions, it&rsquo;s a hell of a task to solve this game for a human, sometimes taking hours. Luckily, we dispose of some good algorithms to solve it, taking only few milliseconds even for the worst case. Let&rsquo;s explore them in this tutorial! :)</p>

<!-- more -->


<h2>Finding the correct abstraction</h2>

<p>The hardest part of a problem is surely finding a useful abstraction for it, that allows a solution to be even thought! Like most path finding problems, the sliding puzzle can be correctly abstracted as a <strong>graph</strong>, i.e., a set of vertices connected by edges.</p>

<p>It&rsquo;s common to use the term &ldquo;<strong>state</strong>&rdquo; to designate vertices. The meaning of a state depends on the problem. For example, for the sliding puzzle, each state is a determined disposition of pieces. Logically, there&rsquo;s also a &ldquo;<strong>goal state</strong>&rdquo;, a state where the problem is solved. Finally, the edges are the allowed actions that takes our problem from a state to another. For example, in the sliding puzzle, the set of allowed actions is to move the blank space in four directions (up, down, left, right). The figure below illustrates well those concepts.</p>

<p style="text-align:center;"><img src="http://www.ibm.com/developerworks/library/j-ai-search/figure06.png" alt="" /></p>

<p>Assimilated those concepts, our job is simply to find a path from any state to the goal state, and that can be done with any graph search algorithm. Let&rsquo;s discuss the pros/cons of some approaches.</p>

<h2>Javascript implementation of Sliding Puzzle</h2>

<p>Before discussing about specific algorithms, let&rsquo;s implement the building blocks. I&rsquo;ll start with a class called &ldquo;Puzzle&rdquo;, containing basically four attributes: dimension (dimension of our puzzle, i.e., 3 = 8-puzzle, 4 = 15-puzzle, etc.,&hellip;), the board (two-dimensional numeric array), the path and the last performed move (we will cover those last two later).</p>

<pre><code class="javascript sliding-puzzle.js">function Puzzle(dimension) {
    this.dimension = dimension;
    this.board = [];
    this.path = [];
    this.lastMove = null;
    // Fill the board
    for (var i = 0; i &lt; dimension; i++) {
        this.board.push([]);
        for (var j = 0; j &lt; dimension; j++) {
            if (i == this.dimension - 1 &amp;&amp; j == this.dimension - 1) {
                this.board[i].push(0);
            } else {
                this.board[i].push(dimension * i + j + 1);
            }
        }
    }
}
</code></pre>

<p>Let&rsquo;s create some utilitary methods that will help during the craft of our solution:</p>

<pre><code class="javascript sliding-puzzle.js">// Get the (x, y) position of the blank space
Puzzle.prototype.getBlankSpacePosition = function() {
    for (var i = 0; i &lt; this.dimension; i++) {
        for (var j = 0; j &lt; this.dimension; j++) {
            if (this.board[i][j] == 0) {
                return [i, j];
            }
        }
    }
};

// Swap two items on a bidimensional array
Puzzle.prototype.swap = function(i1, j1, i2, j2) {
    var temp = this.board[i1][j1];
    this.board[i1][j1] = this.board[i2][j2];
    this.board[i2][j2] = temp;
}
</code></pre>

<p>And finally, let&rsquo;s implement the methods that will move the pieces:</p>

<pre><code class="javascript sliding-puzzle.js">Direction = {
    LEFT: "left",
    RIGHT: "right",
    UP: "up",
    DOWN: "dow"
};

// Return the direction that a piece can be moved, if any
Puzzle.prototype.getMove = function(piece) {
    var blankSpacePosition = this.getBlankSpacePosition();
    var line = blankSpacePosition[0];
    var column = blankSpacePosition[1];
    if (line &gt; 0 &amp;&amp; piece == this.board[line-1][column]) {
        return Direction.DOWN;
    } else if (line &lt; this.dimension - 1 &amp;&amp; piece == this.board[line+1][column]) {
        return Direction.UP;
    } else if (column &gt; 0 &amp;&amp; piece == this.board[line][column-1]) {
        return Direction.RIGHT;
    } else if (column &lt; this.dimension - 1 &amp;&amp; piece == this.board[line][column+1]) {
        return Direction.LEFT;
    }
};

// Move a piece, if possible, and return the direction that it was moved
Puzzle.prototype.move = function(piece) {
    var move = this.getMove(piece);
    if (move != null) {
        var blankSpacePosition = this.getBlankSpacePosition();
        var line = blankSpacePosition[0];
        var column = blankSpacePosition[1];
        switch (move) {
        case Direction.LEFT:
            this.swap(line, column, line, column + 1);
            break;
        case Direction.RIGHT:
            this.swap(line, column, line, column - 1);
            break;
        case Direction.UP:
            this.swap(line, column, line + 1, column);
            break;
        case Direction.DOWN:
            this.swap(line, column, line - 1, column);
            break;
        }
        if (move != null) {
            this.lastMove = piece;
        }
        return move;
    }
};
</code></pre>

<h2>Breadth-First Search (BFS)</h2>

<p>The most well-known graph search algorithm, along with Depth-First Search (DFS). I believe you are already familiarized with this algorithm. It works really simple: For each visited node, its immediate children are stored on a queue, and it&rsquo;s performed recursively until the queue is empty or a goal state is reached, that way transversing the graph &ldquo;level-by-level&rdquo;.</p>

<p>In order to implement the BFS, we are going to need first two method beforehand: &ldquo;<strong>isGoalState</strong>&rdquo; and &ldquo;<strong>visit</strong>&rdquo;. The &ldquo;isGoalState&rdquo; will check if the current state is a solution to the puzzle, while &ldquo;visit&rdquo; will generate the immediate children of the current state in the state space.</p>

<p>Let&rsquo;s start with &ldquo;isGoalState&rdquo;. Well, it&rsquo;s kinda simple: We are in a goal state if all pieces are in their places. The original place of a piece can be defined as <code>[(piece - 1) % dimension, (piece - 1) / dimension]</code>. Let&rsquo;s take some examples to check if this formule makes sense:</p>

<pre><code>piece = 1
dimension = 3 (8-puzzle)
original place = [(1 - 1) % 3, (1 - 1) / 3] = [0, 0]

piece = 7
dimension = 4 (15-puzzle)
original place = [(7 - 1) % 4, (7 - 1) / 4] = [2, 1]
</code></pre>

<p>Seems correct so far. That way our method is as follows:</p>

<pre><code class="javascript sliding-puzzle.js">Puzzle.prototype.isGoalState = function() {
    for (var i = 0; i &lt; this.dimension; i++) {
        for (var j = 0; j &lt; this.dimension; j++) {
            var piece = this.board[i][j];
            if (piece != 0) {
                var originalLine = Math.floor((piece - 1) / this.dimension);
                var originalColumn = (piece - 1) % this.dimension;
                if (i != originalLine || j != originalColumn) return false;
            }
        }
    }
    return true;
};
</code></pre>

<p>About the &ldquo;visit&rdquo; method, first we need to know all allowed moves we can do in a certain state. For example, if the blank space is on the bottom-left of screen, we may not be able to move down nor left. Luckily, this functionality is already implemented through the method &ldquo;getMove&rdquo; described on previous section.</p>

<pre><code>// Return all current allowed moves
Puzzle.prototype.getAllowedMoves = function() {
    var allowedMoves = [];
    for (var i = 0; i &lt; this.dimension; i++) {
        for (var j = 0; j &lt; this.dimension; j++) {
            var piece = this.board[i][j];
            if (this.getMove(piece) != null) {
                allowedMoves.push(piece);
            }
        }
    }
    return allowedMoves;
};
</code></pre>

<p>But knowing the allowed moves is not enough. We need to generate new states. In order to do that, we are going to need an utilitary method that makes a copy of the current state:</p>

<pre><code>// Return a copy of current puzzle
Puzzle.prototype.getCopy = function() {
    var newPuzzle = new Puzzle(this.dimension);
    for (var i = 0; i &lt; this.dimension; i++) {
        for (var j = 0; j &lt; this.dimension; j++) {
            newPuzzle.board[i][j] = this.board[i][j];
        }
    }
    for (var i = 0; i &lt; this.path.length; i++) {
        newPuzzle.path.push(this.path[i]);
    }
    return newPuzzle;
};
</code></pre>

<p>Notice that we are not just copying the board, but also the path. &ldquo;path&rdquo; is an attribute that stores the pieces that were moved so far, that way allowing us to reexecute the whole process when a goal state is found.</p>

<p>And now we can finally implement it:</p>

<pre><code class="javascript sliding-puzzle.js">Puzzle.prototype.visit = function() {
    var children = [];
    var allowedMoves = this.getAllowedMoves();
    for (var i = 0; i &lt; allowedMoves.length; i++)  {
        var move = allowedMoves[i];
        if (move != this.lastMove) {
            var newInstance = this.getCopy();
            newInstance.move(move);
            newInstance.path.push(move);
            children.push(newInstance);
        }
    }
    return children;
};
</code></pre>

<p>Notice that we are ignoring moves that are equal to &ldquo;lastMove&rdquo;. There&rsquo;s a reason behind it: Moving a piece that was already moved on the last turn will only make it to turn back to its original position! In another words, going back to a state that was already explored. That why we are &ldquo;prunning&rdquo; the tree avoiding this kind of behavior.</p>

<p>*sigh* After all those necessary things, we are now ready to finally implement the BFS algorithm, that is ridiculously simple:</p>

<pre><code class="javascript sliding-puzzle.js">Puzzle.prototype.solveBFS = function() {
    var startingState = this.getCopy();
    startingState.path = [];
    var states = [startingState];
    while (states.length &gt; 0) {
        var state = states[0];
        states.shift();
        if (state.isGoalState()) {
            return state.path;
        }
        states = states.concat(state.visit());
    }
};
</code></pre>

<p>We create an array called &ldquo;states&rdquo; to store the states that are waiting to be visited and put the current state on it. On a loop, we remove the first element (through the &ldquo;shift&rdquo; method, remember we are simulating a queue) and then check if that element is a goal state. If it is, return the sets of steps from our initial state until it (the &ldquo;path&rdquo; attribute), otherwise visit it and append the immediate children to the list of states.</p>

<p><strong>*BONUS*</strong>! You can check a simulation below:</p>

<center>
    <h3>BFS</h3>
    <div>
        <div id="container-bfs" class="puzzle"></div>
        <br>
        Time elapsed: <span id="elapsed">0</span>ms
        <br>
        <button id="shuffle">Shuffle</button>
        <button id="solve">Solve</button>
    </div>
</center>




<script type="text/javascript">
    new PuzzleGUI($("#container-bfs"), 4, 50, 5, 100, 10, Algorithm.BFS);
</script>


<p><strong>PRO</strong>: It&rsquo;s easy to be implemented.<br>
<strong>CON</strong>: Waaaaaaay too slow.</p>

<h2>A*</h2>

<p>As we saw previously, the BFS can correctly find an optimal solution to our problem, i.e., find a path from the starting state to the goal state with the minimum number of steps, but it has a huge drawback: it&rsquo;s too slow! If you shuffle the game too much and try to run it, it will possibly freeze your browser.</p>

<p>So here&rsquo;s the A*, the top #1 favorite algorithm for problem solving agents, and, good for us, it&rsquo;s pretty simple too!</p>

<p>It works similarly to BFS, but with some differences: Instead of a queue, we use a priority queue (a.k.a., min-heap), that is a data structure that instead of returning the first element added, it returns the element with lowest value. And, to each discovered state, we assign a value to it, that can be defined as:</p>

<p>f(n) = g(n) + h(n)</p>

<p>g(n) (called <strong>real cost function</strong>) is the cost necessary to go from the starting state to the state n. Since we already discovered the whole path to it, we can easily calculate that cost with precision (for our sliding puzzle example, that cost can be represented as the path length, for example).</p>

<p>h(n) (called <strong>heuristic function</strong>) is the estimated cost to go from the state n to the goal state. But here&rsquo;s the trick: We don&rsquo;t know the path from state n to the goal state yet! It&rsquo;s called <em>heuristic</em> precisely because we use heuristics to estimate it.</p>

<p>For priority-queue implementation, I&rsquo;m going to use that you can you find <a href="http://www.digitaltsunami.net/projects/javascript/minheap/index.html">here</a>.</p>

<p>Let&rsquo;s start initializing the algorithm:</p>

<pre><code class="javascript sliding-puzzle.js">Puzzle.prototype.solveA = function() {
    var states = new MinHeap(null, function(a, b) {
        return a.distance - b.distance;
    });
    this.path = [];
    states.push({puzzle: this, distance: 0});
};
</code></pre>

<p>Now, on a loop, we are going to retrieve the items with lowest value until the &ldquo;states&rdquo; variable is empty or a goal state is reached.</p>

<pre><code class="javascript sliding-puzzle.js">Puzzle.prototype.solveA = function() {
    var states = new MinHeap(null, function(a, b) {
        return a.distance - b.distance;
    });
    this.path = [];
    states.push({puzzle: this, distance: 0});
    while (states.size() &gt; 0) {
        var state = states.pop().puzzle;
        if (state.isGoalState()) {
            return state.path;
        }
    }
};
</code></pre>

<p>And finally, we are going to visit the retrieved state&rsquo;s children, calculate their weights and insert them into the queue.</p>

<pre><code class="javascript sliding-puzzle.js">Puzzle.prototype.solveA = function() {
    var states = new MinHeap(null, function(a, b) {
        return a.distance - b.distance;
    });
    this.path = [];
    states.push({puzzle: this, distance: 0});
    while (states.size() &gt; 0) {
        var state = states.pop().puzzle;
        if (state.isGoalState()) {
            return state.path;
        }
        var children = state.visit();
        for (var i = 0; i &lt; children.length; i++) {
            var child = children[i];
            var f = child.g() + child.h();
            states.push({puzzle : child, distance: f});
        }
    }
};
</code></pre>

<p>Good, good. Now let&rsquo;s implement the &ldquo;g&rdquo; and &ldquo;h&rdquo; functions. For &ldquo;g&rdquo; function, I&rsquo;ll simply count the path length (what else could be considered as the real cost?):</p>

<pre><code class="javascript sliding-puzzle.js">Puzzle.prototype.g = function() {
    return this.path.length;
};
</code></pre>

<p>The heuristic function is the tricky part. We could think in many things. It&rsquo;s important the heuristic be <strong>admissible</strong>, i.e., it must underestimate the real cost until the goal state. The closer the estimated value by heuristic function is to the real cost to go to the goal state, the better.</p>

<h3>Heuristic #1: Misplaced tiles</h3>

<p>This function counts simply the number of pieces(tiles) that are not in their final position. This function is almost identical to the one we implemented to check if a state is the goal:</p>

<pre><code class="javascript sliding-puzzle.js">Puzzle.prototype.h = function() {
    var count = 0;
    for (var i = 0; i &lt; this.dimension; i++) {
        for (var j = 0; j &lt; this.dimension; j++) {
            var piece = this.board[i][j];
            if (piece != 0) {
                var originalLine = Math.floor((piece - 1) / this.dimension);
                var originalColumn = (piece - 1) % this.dimension;
                if (i != originalLine || j != originalColumn) count++;
            }
        }
    }   
    return count;
}
</code></pre>



<center>
    <h3>A*: Misplaced tiles</h3>
    <div>
        <div id="container-a-misplaced" class="puzzle"></div>
        <br>
        Time elapsed: <span id="elapsed">0</span>ms
        <br>
        <button id="shuffle">Shuffle</button>
        <button id="solve">Solve</button>
    </div>
</center>


<p></p>

<script type="text/javascript">
    new PuzzleGUI($("#container-a-misplaced"), 4, 50, 5, 100, 10, Algorithm.AMisplaced);
</script>


<h3>Heuristic #2: Manhattan distance</h3>

<p>Instead of just counting the number of misplaced tiles, this heuristic function calculates the manhattan distance (L1 distance) between the current misplaced position and the final position. Manhattan distance can be calculated as:</p>

<p>d(x1, y1, x2, y2) = |x1 - x2| + |y1 - y2|</p>

<pre><code class="javascript sliding-puzzle.js">Puzzle.prototype.h = function() {
    var distance = 0;
    for (var i = 0; i &lt; this.dimension; i++) {
        for (var j = 0; j &lt; this.dimension; j++) {
            var piece = this.board[i][j];
            if (piece != 0) {
                var originalLine = Math.floor((piece - 1) / this.dimension);
                var originalColumn = (piece - 1) % this.dimension;
                distance += Math.abs(i - originalLine) + Math.abs(j - originalColumn);
            }
        }
    }   
    return distance;
}
</code></pre>



<center>
    <h3>A*: Manhattan distance</h3>
    <div>
        <div id="container-a-manhattan" class="puzzle"></div>
        <br>
        Time elapsed: <span id="elapsed">0</span>ms
        <br>
        <button id="shuffle">Shuffle</button>
        <button id="solve">Solve</button>
    </div>
</center>


<p></p>

<script type="text/javascript">
    new PuzzleGUI($("#container-a-manhattan"), 4, 50, 5, 100, 10, Algorithm.AManhattan);
</script>


<p>This heuristic is obviously better than the previous, since it always yields a higher value and hence closer to the real cost.</p>

<h2>Full code</h2>

<p>You can get the full code here:</p>

<center><input id="spoiler" type="button" value="See source code" onclick="toggle_visibility('code');"></center>


<div id="code">
<figure class='code'><figcaption><span>sliding-puzzle.js</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">Direction</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">LEFT</span><span class="o">:</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">RIGHT</span><span class="o">:</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">UP</span><span class="o">:</span> <span class="s2">&quot;up&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">DOWN</span><span class="o">:</span> <span class="s2">&quot;dow&quot;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Algorithm</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">BFS</span><span class="o">:</span> <span class="s2">&quot;BFS&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">AMisplaced</span><span class="o">:</span> <span class="s2">&quot;A*: Misplaced tiles&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">AManhattan</span><span class="o">:</span> <span class="s2">&quot;A*: Manhattan distance&quot;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">Puzzle</span><span class="p">(</span><span class="nx">dimension</span><span class="p">,</span> <span class="nx">solve_func</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">board</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span> <span class="o">=</span> <span class="nx">dimension</span><span class="p">;</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">solve_func</span> <span class="o">=</span> <span class="nx">solve_func</span><span class="p">;</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">lastMove</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">dimension</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">dimension</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">==</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">==</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">dimension</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Get the (x, y) position of the blank space</span>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getBlankSpacePosition</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Swap two items on a bidimensional array</span>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">swap</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">i1</span><span class="p">,</span> <span class="nx">j1</span><span class="p">,</span> <span class="nx">i2</span><span class="p">,</span> <span class="nx">j2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i1</span><span class="p">][</span><span class="nx">j1</span><span class="p">];</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i1</span><span class="p">][</span><span class="nx">j1</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i2</span><span class="p">][</span><span class="nx">j2</span><span class="p">];</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i2</span><span class="p">][</span><span class="nx">j2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Return the direction that a piece can be moved, if any</span>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getMove</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">piece</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">blankSpacePosition</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getBlankSpacePosition</span><span class="p">();</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">line</span> <span class="o">=</span> <span class="nx">blankSpacePosition</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">column</span> <span class="o">=</span> <span class="nx">blankSpacePosition</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">line</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">piece</span> <span class="o">==</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">line</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">column</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">Direction</span><span class="p">.</span><span class="nx">DOWN</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">line</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">piece</span> <span class="o">==</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">line</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">column</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">Direction</span><span class="p">.</span><span class="nx">UP</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">column</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">piece</span> <span class="o">==</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">line</span><span class="p">][</span><span class="nx">column</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">Direction</span><span class="p">.</span><span class="nx">RIGHT</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">column</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">piece</span> <span class="o">==</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">line</span><span class="p">][</span><span class="nx">column</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">Direction</span><span class="p">.</span><span class="nx">LEFT</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Move a piece, if possible, and return the direction that it was moved</span>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">move</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">piece</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">move</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getMove</span><span class="p">(</span><span class="nx">piece</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">move</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">blankSpacePosition</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getBlankSpacePosition</span><span class="p">();</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">line</span> <span class="o">=</span> <span class="nx">blankSpacePosition</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">column</span> <span class="o">=</span> <span class="nx">blankSpacePosition</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>        <span class="k">switch</span> <span class="p">(</span><span class="nx">move</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Direction</span><span class="p">.</span><span class="nx">LEFT</span><span class="o">:</span>
</span><span class='line'>            <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="nx">column</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">column</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Direction</span><span class="p">.</span><span class="nx">RIGHT</span><span class="o">:</span>
</span><span class='line'>            <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="nx">column</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">column</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Direction</span><span class="p">.</span><span class="nx">UP</span><span class="o">:</span>
</span><span class='line'>            <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="nx">column</span><span class="p">,</span> <span class="nx">line</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">column</span><span class="p">);</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Direction</span><span class="p">.</span><span class="nx">DOWN</span><span class="o">:</span>
</span><span class='line'>            <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="nx">column</span><span class="p">,</span> <span class="nx">line</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">column</span><span class="p">);</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nx">move</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">this</span><span class="p">.</span><span class="nx">lastMove</span> <span class="o">=</span> <span class="nx">piece</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">move</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">isGoalState</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">piece</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="nx">piece</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">originalLine</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">piece</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">);</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">originalColumn</span> <span class="o">=</span> <span class="p">(</span><span class="nx">piece</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">!=</span> <span class="nx">originalLine</span> <span class="o">||</span> <span class="nx">j</span> <span class="o">!=</span> <span class="nx">originalColumn</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Return a copy of current puzzle</span>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getCopy</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">newPuzzle</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Puzzle</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">newPuzzle</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">newPuzzle</span><span class="p">.</span><span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">newPuzzle</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Return all current allowed moves</span>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getAllowedMoves</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">allowedMoves</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">piece</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getMove</span><span class="p">(</span><span class="nx">piece</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="nx">allowedMoves</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">piece</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">allowedMoves</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">visit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">allowedMoves</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getAllowedMoves</span><span class="p">();</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">allowedMoves</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">move</span> <span class="o">=</span> <span class="nx">allowedMoves</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nx">move</span> <span class="o">!=</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastMove</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">newInstance</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getCopy</span><span class="p">();</span>
</span><span class='line'>            <span class="nx">newInstance</span><span class="p">.</span><span class="nx">move</span><span class="p">(</span><span class="nx">move</span><span class="p">);</span>
</span><span class='line'>            <span class="nx">newInstance</span><span class="p">.</span><span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">move</span><span class="p">);</span>
</span><span class='line'>            <span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">newInstance</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">children</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">solveBFS</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">startingState</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getCopy</span><span class="p">();</span>
</span><span class='line'>    <span class="nx">startingState</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">states</span> <span class="o">=</span> <span class="p">[</span><span class="nx">startingState</span><span class="p">];</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="nx">states</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="nx">states</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>        <span class="nx">states</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">isGoalState</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nx">path</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="nx">states</span> <span class="o">=</span> <span class="nx">states</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">visit</span><span class="p">());</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getManhattanDistance</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">distance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">piece</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="nx">piece</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">originalLine</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">piece</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">);</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">originalColumn</span> <span class="o">=</span> <span class="p">(</span><span class="nx">piece</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span>
</span><span class='line'>                <span class="nx">distance</span> <span class="o">+=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="nx">originalLine</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">j</span> <span class="o">-</span> <span class="nx">originalColumn</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">distance</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">countMisplaced</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">piece</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="nx">piece</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">originalLine</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">piece</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">);</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">originalColumn</span> <span class="o">=</span> <span class="p">(</span><span class="nx">piece</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimension</span><span class="p">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">!=</span> <span class="nx">originalLine</span> <span class="o">||</span> <span class="nx">j</span> <span class="o">!=</span> <span class="nx">originalColumn</span><span class="p">)</span> <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">h</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">solve_func</span> <span class="o">==</span> <span class="nx">Algorithm</span><span class="p">.</span><span class="nx">AMisplaced</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">countMisplaced</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">getManhattanDistance</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">solveA</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">states</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MinHeap</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">distance</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">distance</span><span class="p">;</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'>    <span class="nx">states</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="nx">puzzle</span><span class="o">:</span> <span class="k">this</span><span class="p">,</span> <span class="nx">distance</span><span class="o">:</span> <span class="mi">0</span><span class="p">});</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="nx">states</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="nx">states</span><span class="p">.</span><span class="nx">pop</span><span class="p">().</span><span class="nx">puzzle</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">isGoalState</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nx">path</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">visit</span><span class="p">();</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">children</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">g</span><span class="p">()</span> <span class="o">+</span> <span class="nx">child</span><span class="p">.</span><span class="nx">h</span><span class="p">();</span>
</span><span class='line'>            <span class="nx">states</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="nx">puzzle</span> <span class="o">:</span> <span class="nx">child</span><span class="p">,</span> <span class="nx">distance</span><span class="o">:</span> <span class="nx">f</span><span class="p">});</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Puzzle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">solve</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">solve_func</span> <span class="o">==</span> <span class="nx">Algorithm</span><span class="p">.</span><span class="nx">BFS</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">solveBFS</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">solveA</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure> 
</div>


<p></input></p>

<p>And since this page itself is utilizing this code for demonstration, you can also get it visualizing the source code.</p>

<h2>Conclusion</h2>

<p>Well, that was a quite interesting tutorial. We discussed about <strong>space of states</strong>, <strong>goal state</strong>, <strong>graph search algorithms</strong>, <strong>A*</strong> and <strong>admissible heuristics</strong>. I hope you have enjoyed reading this tutorial as much as I did writing it. See ya on the next tutorial! :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fingertip Detection in OpenCV]]></title>
    <link href="http://abner-math.github.io/blog/2015/11/15/fingertip-detection-on-opencv/"/>
    <updated>2015-11-15T00:06:15-03:00</updated>
    <id>http://abner-math.github.io/blog/2015/11/15/fingertip-detection-on-opencv</id>
    <content type="html"><![CDATA[<p>Hi! In this tutorial, we will learn how to detect fingertips using OpenCV. You ready? :D</p>

<p style="text-align:center;"><img src="/images/posts/fingertip1.png" alt="" /></p>

<!-- more -->


<p>In computer vision, the task of recognizing an object in the scene is very common. Unhappily, there is no &ldquo;silver bullet&rdquo; which can solve this problem for all kinds of objects. Each case must be treated individually (luckily it&rsquo;s changing with the rising of convolutional neural networks). In this case, we are interested in discover the location of fingertips (if any is present) in the image.</p>

<p>Firstly, let me present you OpenCV, a open-source library for computer vision and digital image processing. It has many facilities which makes our daily life so much easier. :) (If you don&rsquo;t have OpenCV, I recommend following <a href="http://docs.opencv.org/2.4/doc/tutorials/introduction/table_of_content_introduction/table_of_content_introduction.html#table-of-content-introduction">this</a> tutorial).</p>

<p>The first step before detecting the fingertips is to detect the hand, obviously. But how to do it? With color segmentation! You see, let&rsquo;s assume you&rsquo;re in front of a background with a much different color from your skin. Also, let&rsquo;s assume that your hand is the largest part of your body showing up. In this scenario, recognizing the hand would be easy, by simply selecting the pixels belonging to the color of your skin and then retrieving the largest area. That&rsquo;s precisely what we&rsquo;ll do!</p>

<h2>Segmenting the hand skin</h2>

<p>If you ever used any image manipulation software, you should know that there are several color spaces. The most common is the RGB, where any pixel is composed by the union of three colors (red, green, blue). However, for color segmenting, the HSV color space is much better, because in there the information of color is dissociated from the information of illumination. HSV stands for <strong>H</strong>ue (the color information), <strong>S</strong> (saturation, e.g., the percentage of &lsquo;color&rsquo; present) and <strong>V</strong> (value/brightness, e.g., the percentage of &lsquo;white&rsquo; color present). Generally, human skin lies between (H=0,S=58) and (H=50,S=173).</p>

<p>Let&rsquo;s start implementing our detector. The first thing we need is to read the image from the webcam. OpenCV contains a module (imgproc) responsible for capturing images and videos.</p>

<pre><code class="C++ fingertip_detector.cpp">#include &lt;iostream&gt;

#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;

int main()
{
    cv::VideoCapture cap(0);
    const char* windowName = "Fingertip detection";
    while (1)
    {
        cv::Mat frame;
        cap &gt;&gt; frame;
        cv::imshow(windowName, frame);
        if (cv::waitKey(30) &gt;= 0) break;
    }
    return 0;
}
</code></pre>

<p>The argument passed to the &ldquo;VideoCapture&rdquo; object indicates the index of camera that we want to access (in case you have more than one connected to your computer). In a loop, we are getting a frame from the camera (through the >> operator) each 30 milliseconds (the argument of &ldquo;waitKey&rdquo; function, which waits x milliseconds until a key has been pressed, and returns -1 if none was pressed). Finally, we show the captured frame on the screen (through the &ldquo;imshow&rdquo; function).</p>

<p>Now, let&rsquo;s convert our captured frame (which is in the BGR color space, e.g, inverted RGB) to HSV and then segment the color using the &ldquo;inRange&rdquo; operator:</p>

<pre><code class="c++ fingertip_detector.cpp">int main()
{
    cv::VideoCapture cap(0);
    const char* windowName = "Fingertip detection";
    int minH = 130, maxH = 160, minS = 10, maxS = 40, minV = 75, maxV = 130;
    while (1)
    {
        cv::Mat frame;
        cap &gt;&gt; frame;
        cv::Mat hsv;
        cv::cvtColor(frame, hsv, CV_BGR2HSV);
        cv::inRange(hsv, cv::Scalar(minH, minS, minV), cv::Scalar(maxH, maxS, maxV), hsv);
        cv::imshow(windowName, hsv);
        if (cv::waitKey(30) &gt;= 0) break;
    }
    return 0;
}
</code></pre>

<p>The &ldquo;inRange&rdquo; function receives the image that we want to threshold, the interval lower bound, the interval upper bound and the output image. The result is a black and white image, where pixels that have values inside the interval are colored with white, otherwise black.</p>

<p style="text-align:center;"><img src="/images/posts/fingertip2.png" alt="" /></p>

<p>As you can notice, this is a poor segmentation. We need to do a fine-tuning of HSV bounds in order to get a good segmentation. Since changing the value and recompiling the program is boring, it&rsquo;s better to use trackbars for this task:</p>

<pre><code class="C++ fingertip_detector.cpp">int main()
{
    cv::VideoCapture cap(0);
    const char* windowName = "Fingertip detection";
    int minH = 130, maxH = 160, minS = 10, maxS = 40, minV = 75, maxV = 130;
    cv::namedWindow(windowName);
    cv::createTrackbar("MinH", windowName, &amp;minH, 180);
    cv::createTrackbar("MaxH", windowName, &amp;maxH, 180);
    cv::createTrackbar("MinS", windowName, &amp;minS, 255);
    cv::createTrackbar("MaxS", windowName, &amp;maxS, 255);
    cv::createTrackbar("MinV", windowName, &amp;minV, 255);
    cv::createTrackbar("MaxV", windowName, &amp;maxV, 255);
    while (1)
    {
        cv::Mat frame;
        cap &gt;&gt; frame;
        cv::Mat hsv;
        cv::cvtColor(frame, hsv, CV_BGR2HSV);
        cv::inRange(hsv, cv::Scalar(minH, minS, minV), cv::Scalar(maxH, maxS, maxV), hsv);
        cv::imshow(windowName, hsv);
        if (cv::waitKey(30) &gt;= 0) break;
    }
    return 0;
}
</code></pre>

<p style="text-align:center;"><img src="/images/posts/fingertip3.png" alt="" /></p>

<p>Even after adjusting the interval there is too much noise. We need to apply special techniques like <strong>median blur</strong> to remove isolated dots and <strong>dilate</strong> to fill &ldquo;holes&rdquo;:</p>

<pre><code class="C++ fingertip_detector.cpp">int main()
{
    ...
    while (1)
    {
        cv::Mat frame;
        cap &gt;&gt; frame;
        cv::Mat hsv;
        cv::cvtColor(frame, hsv, CV_BGR2HSV);
        cv::inRange(hsv, cv::Scalar(minH, minS, minV), cv::Scalar(maxH, maxS, maxV), hsv);
        int blurSize = 5;
        int elementSize = 5;
        cv::medianBlur(hsv, hsv, blurSize);
        cv::Mat element = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(2 * elementSize + 1, 2 * elementSize + 1), cv::Point(elementSize, elementSize));
        cv::dilate(hsv, hsv, element);
        cv::imshow(windowName, hsv);
        if (cv::waitKey(30) &gt;= 0) break;
    }
    return 0;
}
</code></pre>

<p style="text-align:center;"><img src="/images/posts/fingertip4.png" alt="" /></p>

<p>Hmmm&hellip; Much better! :D But there is still some outliers&hellip; We can fix it by finding the contours of separated objects present in the thresholded image and then using only the object that has the contour with largest area.</p>

<pre><code class="C++ fingertip_detector.cpp">int main()
{
    ...
    while (1)
    {
        cap &gt;&gt; frame;
        cv::Mat hsv;
        cv::cvtColor(frame, hsv, CV_BGR2HSV);
        cv::inRange(hsv, cv::Scalar(minH, minS, minV), cv::Scalar(maxH, maxS, maxV), hsv);
        // Pre processing
        int blurSize = 5;
        int elementSize = 5;
        cv::medianBlur(hsv, hsv, blurSize);
        cv::Mat element = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(2 * elementSize + 1, 2 * elementSize + 1), cv::Point(elementSize, elementSize));
        cv::dilate(hsv, hsv, element);
        // Contour detection
        std::vector&lt;std::vector&lt;cv::Point&gt; &gt; contours;
        std::vector&lt;cv::Vec4i&gt; hierarchy;
        cv::findContours(hsv, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));
        size_t largestContour = 0;
        for (size_t i = 1; i &lt; contours.size(); i++)
        {
            if (cv::contourArea(contours[i]) &gt; cv::contourArea(contours[largestContour]))
                largestContour = i;
        }
        cv::drawContours(frame, contours, largestContour, cv::Scalar(0, 0, 255), 1);
        cv::imshow(windowName, frame);
        if (cv::waitKey(30) &gt;= 0) break;
    }
    return 0;
}
</code></pre>

<p style="text-align:center;"><img src="/images/posts/fingertip5.png" alt="" /></p>

<p>The &ldquo;findContours&rdquo; function expects to receive a vector of vector of points, or, in another words, a vector of polygons. There are many detection methods. Here I chose &ldquo;CV_RETR_EXTERNAL&rdquo;, which means it will just return the most external contour, ignoring eventual contours that are inside the most external region. I then compare the areas of the returned polygons (through the &ldquo;contourArea&rdquo; function) to get the largest and then draw it on screen (through the &ldquo;drawContours&rdquo; function). We can see clearly that the result is the contour of my hand with a tiny red line. So we accomplished the task of segmenting our hand successfully. Let&rsquo;s move to the next step.</p>

<h2>Detecting fingertips</h2>

<p>In order to detect fingertips, we are going to use the <strong>Convex Hull</strong> technique. In mathematics, Convex Hull is the smallest convex set that contains a set of points. And a convex set is a set of points such that, if we trace a straight line from any pair of points in the set, that line must be also be inside the region. The result is then a nice, smooth region, much easier to be analised than our contour, that contains many imperfections. Luckily, this algorithm is also implemented on OpenCV through the &ldquo;convexHull&rdquo; function.</p>

<pre><code class="C++ fingertip_detector.cpp">int main()
{
    ...
    while (1)
    {
        cap &gt;&gt; frame;
        cv::Mat hsv;
        cv::cvtColor(frame, hsv, CV_BGR2HSV);
        cv::inRange(hsv, cv::Scalar(minH, minS, minV), cv::Scalar(maxH, maxS, maxV), hsv);
        // Pre processing
        int blurSize = 5;
        int elementSize = 5;
        cv::medianBlur(hsv, hsv, blurSize);
        cv::Mat element = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(2 * elementSize + 1, 2 * elementSize + 1), cv::Point(elementSize, elementSize));
        cv::dilate(hsv, hsv, element);
        // Contour detection
        std::vector&lt;std::vector&lt;cv::Point&gt; &gt; contours;
        std::vector&lt;cv::Vec4i&gt; hierarchy;
        cv::findContours(hsv, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));
        size_t largestContour = 0;
        for (size_t i = 1; i &lt; contours.size(); i++)
        {
            if (cv::contourArea(contours[i]) &gt; cv::contourArea(contours[largestContour]))
                largestContour = i;
        }
        cv::drawContours(frame, contours, largestContour, cv::Scalar(0, 0, 255), 1);
        // Convex hull
        if (!contours.empty())
        {
            std::vector&lt;std::vector&lt;cv::Point&gt; &gt; hull(1);
            cv::convexHull(cv::Mat(contours[largestContour]), hull[0], false);
            cv::drawContours(frame, hull, 0, cv::Scalar(0, 255, 0), 3);
        }
        cv::imshow(windowName, frame);
        if (cv::waitKey(30) &gt;= 0) break;
    }
    return 0;
}
</code></pre>

<p style="text-align:center;"><img src="/images/posts/fingertip6.png" alt="" /></p>

<p>We are just calculating the convex hull of our largest contour (in order to speed the process). The &ldquo;convexHull&rdquo; function expects to receive a set of polygons, just like the &ldquo;findContours&rdquo; function. Hence, drawing the region on screen follows the same logic.</p>

<p>It&rsquo;s already pretty easy detecting the fingertips through the Convex Hull region. Their locations coincide with the &ldquo;corners&rdquo; of our Convex Hull polygon. But instead of doing it manually, we are going to detect it with the aid of &ldquo;<strong>convextDefects</strong>&rdquo; function. You see, there are &ldquo;gaps&rdquo; between the convex hull region and our contour region. The &ldquo;convexDefects&rdquo; will try to approximate those gaps using straight lines. We can then use that information to find the points where our fingertips are placed.</p>

<pre><code class="C++ fingertip_detector.cpp">int main()
{
    ...
    while (1)
    {
        ...
        // Convex hull
        if (!contours.empty())
        {
            std::vector&lt;std::vector&lt;cv::Point&gt; &gt; hull(1);
            cv::convexHull(cv::Mat(contours[largestContour]), hull[0], false);
            cv::drawContours(frame, hull, 0, cv::Scalar(0, 255, 0), 3);
            if (hull[0].size() &gt; 2)
            {
                std::vector&lt;int&gt; hullIndexes;
                cv::convexHull(cv::Mat(contours[largestContour]), hullIndexes, true);
                std::vector&lt;cv::Vec4i&gt; convexityDefects;
                cv::convexityDefects(cv::Mat(contours[largestContour]), hullIndexes, convexityDefects);
                for (size_t i = 0; i &lt; convexityDefects.size(); i++)
                {
                    cv::Point p1 = contours[largestContour][convexityDefects[i][0]];
                    cv::Point p2 = contours[largestContour][convexityDefects[i][1]];
                    cv::Point p3 = contours[largestContour][convexityDefects[i][2]];
                    cv::line(frame, p1, p3, cv::Scalar(255, 0, 0), 2);
                    cv::line(frame, p3, p2, cv::Scalar(255, 0, 0), 2);
                }
            }
        }
        cv::imshow(windowName, frame);
        if (cv::waitKey(30) &gt;= 0) break;
    }
    return 0;
}
</code></pre>

<p style="text-align:center;"><img src="/images/posts/fingertip7.png" alt="" /></p>

<p>I drew the convexity defects lines in blue. The &ldquo;convexityDefects&rdquo; function returns a vector of tuples of four values. The first value is the initial point of the defect region. The second value is the ending point of the defect region. The third value is the &ldquo;middle&rdquo; point of the defect region that connects the initial point and the ending point. The result is then two lines: One from the initial point to the middle point and one from middle point to the ending point. What only interests us in the initial point, that is the point where our fingertips are placed. I will draw it to make it more evident.</p>

<p style="text-align:center;"><img src="/images/posts/fingertip8.png" alt="" /></p>

<p>Ta-da! What sucks, however, is that there are far more points than just our fingertips. We need to do a filtering for only the points of our interest. We can think in some cheap but useful heuristics for that: i) Consider the inner angle between the two lines of the defect region to be between a certain interval; ii) Consider the angle between the initial point and the center of the contour region to be between a certain interval; iii) Consider the length of the line from the initial point to the middle point to be above a certain threshold. I think only those three are enough.</p>

<p>The inner angle is exactly the angle between our fingers. The image below illustrates the concept better:</p>

<p style="text-align:center;"><img src="http://simena86.github.io/images/handRecognition/handangle.png" alt="" /></p>

<p>Generally, the angle between our fingers is between 20 and 120. It can be calculated by translating the vector to the origin (by subtracting both by the middle point of the defect region) and then calculating the arc cosine of the inner product divided by the norm of the vectors:</p>

<pre><code>theta = arcos(x . y / |x||y|)
</code></pre>

<p>This nice snippet will do exactly that:</p>

<pre><code class="C++">float innerAngle(float px1, float py1, float px2, float py2, float cx1, float cy1)  
{  

 float dist1 = std::sqrt(  (px1-cx1)*(px1-cx1) + (py1-cy1)*(py1-cy1) );  
 float dist2 = std::sqrt(  (px2-cx1)*(px2-cx1) + (py2-cy1)*(py2-cy1) );  

 float Ax, Ay;  
 float Bx, By;  
 float Cx, Cy;  

 //find closest point to C  
 //printf("dist = %lf %lf\n", dist1, dist2);  

 Cx = cx1;  
 Cy = cy1;  
 if(dist1 &lt; dist2)  
 {    
  Bx = px1;  
  By = py1;    
  Ax = px2;  
  Ay = py2;  


 }else{  
  Bx = px2;  
  By = py2;  
  Ax = px1;  
  Ay = py1;  
 }  


 float Q1 = Cx - Ax;  
 float Q2 = Cy - Ay;  
 float P1 = Bx - Ax;  
 float P2 = By - Ay;    


 float A = std::acos( (P1*Q1 + P2*Q2) / ( std::sqrt(P1*P1+P2*P2) * std::sqrt(Q1*Q1+Q2*Q2) ) );  

 A = A*180/CV_PI;  

 return A;  
}  
</code></pre>

<p>Now, the angle between the initial point and the center of contour region is necessary to erase points located in the lower part of the contour. In order to find the center of the contour, we must involve it with a bounding box. OpenCV already has a function for that called &ldquo;boundingBox&rdquo;. We just are going to consider points that are between -30 and 160.</p>

<p>And finally, the length of line from the initial point to the middle point can be calculated by simply calculating the euclidean distance between the initial point and the middle point.</p>

<p>Crystal clear? Ok, here&rsquo;s the code:</p>

<pre><code class="C++ fingertip_detector.cpp">if (hull[0].size() &gt; 2)
{
    std::vector&lt;int&gt; hullIndexes;
    cv::convexHull(cv::Mat(contours[largestContour]), hullIndexes, true);
    std::vector&lt;cv::Vec4i&gt; convexityDefects;
    cv::convexityDefects(cv::Mat(contours[largestContour]), hullIndexes, convexityDefects);
    cv::Rect boundingBox = cv::boundingRect(hull[0]);
    cv::rectangle(frame, boundingBox, cv::Scalar(255, 0, 0));
    cv::Point center = cv::Point(boundingBox.x + boundingBox.width / 2, boundingBox.y + boundingBox.height / 2);
    std::vector&lt;cv::Point&gt; validPoints;
    for (size_t i = 0; i &lt; convexityDefects.size(); i++)
    {
        cv::Point p1 = contours[largestContour][convexityDefects[i][0]];
        cv::Point p2 = contours[largestContour][convexityDefects[i][1]];
        cv::Point p3 = contours[largestContour][convexityDefects[i][2]];
        double angle = std::atan2(center.y - p1.y, center.x - p1.x) * 180 / CV_PI;
        double inAngle = innerAngle(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
        double length = std::sqrt(std::pow(p1.x - p3.x, 2) + std::pow(p1.y - p3.y, 2));
        if (angle &gt; -30 &amp;&amp; angle &lt; 160 &amp;&amp; std::abs(inAngle) &gt; 20 &amp;&amp; std::abs(inAngle) &lt; 120 &amp;&amp; length &gt; 0.1 * boundingBox.height)
        {
            validPoints.push_back(p1);
        }
    }
    for (size_t i = 0; i &lt; validPoints.size(); i++)
    {
        cv::circle(frame, validPoints[i], 9, cv::Scalar(0, 255, 0), 2);
    }
}
</code></pre>

<p>And the result is good enough:</p>

<p style="text-align:center;"><img src="/images/posts/fingertip10.png" alt="" /></p>

<p>The final code can be found below. I improved it by removing the trackbars from the color and, instead of it, allowing the user to click on the region where the hand is located and it will automatically extract the color information from there. Click again to establish a interval of colors. I also put trackbars for the angles, so you can adjust it during the program execution and check the effect of different intervals.</p>

<center><input id="spoiler" type="button" value="See source code" onclick="toggle_visibility('code');"></center>


<div id="code">
<figure class='code'><figcaption><span>fingertip_detector.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
</pre></td><td class='code'><pre><code class='C++'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;opencv2/core/core.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/highgui/highgui.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;opencv2/imgproc/imgproc.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">minH</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxH</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">minS</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">maxS</span> <span class="o">=</span> <span class="mi">150</span><span class="p">,</span> <span class="n">minV</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span> <span class="n">maxV</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
</span><span class='line'><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">frame</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">float</span> <span class="nf">innerAngle</span><span class="p">(</span><span class="kt">float</span> <span class="n">px1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">py1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">px2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">py2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cx1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cy1</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'> <span class="kt">float</span> <span class="n">dist1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span>  <span class="p">(</span><span class="n">px1</span><span class="o">-</span><span class="n">cx1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">px1</span><span class="o">-</span><span class="n">cx1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">py1</span><span class="o">-</span><span class="n">cy1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">py1</span><span class="o">-</span><span class="n">cy1</span><span class="p">)</span> <span class="p">);</span>
</span><span class='line'> <span class="kt">float</span> <span class="n">dist2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span>  <span class="p">(</span><span class="n">px2</span><span class="o">-</span><span class="n">cx1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">px2</span><span class="o">-</span><span class="n">cx1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">py2</span><span class="o">-</span><span class="n">cy1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">py2</span><span class="o">-</span><span class="n">cy1</span><span class="p">)</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'> <span class="kt">float</span> <span class="n">Ax</span><span class="p">,</span> <span class="n">Ay</span><span class="p">;</span>
</span><span class='line'> <span class="kt">float</span> <span class="n">Bx</span><span class="p">,</span> <span class="n">By</span><span class="p">;</span>
</span><span class='line'> <span class="kt">float</span> <span class="n">Cx</span><span class="p">,</span> <span class="n">Cy</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'> <span class="c1">//find closest point to C  </span>
</span><span class='line'> <span class="c1">//printf(&quot;dist = %lf %lf\n&quot;, dist1, dist2);  </span>
</span><span class='line'>
</span><span class='line'> <span class="n">Cx</span> <span class="o">=</span> <span class="n">cx1</span><span class="p">;</span>
</span><span class='line'> <span class="n">Cy</span> <span class="o">=</span> <span class="n">cy1</span><span class="p">;</span>
</span><span class='line'> <span class="k">if</span><span class="p">(</span><span class="n">dist1</span> <span class="o">&lt;</span> <span class="n">dist2</span><span class="p">)</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>  <span class="n">Bx</span> <span class="o">=</span> <span class="n">px1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">By</span> <span class="o">=</span> <span class="n">py1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Ax</span> <span class="o">=</span> <span class="n">px2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Ay</span> <span class="o">=</span> <span class="n">py2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>  <span class="n">Bx</span> <span class="o">=</span> <span class="n">px2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">By</span> <span class="o">=</span> <span class="n">py2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Ax</span> <span class="o">=</span> <span class="n">px1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Ay</span> <span class="o">=</span> <span class="n">py1</span><span class="p">;</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="kt">float</span> <span class="n">Q1</span> <span class="o">=</span> <span class="n">Cx</span> <span class="o">-</span> <span class="n">Ax</span><span class="p">;</span>
</span><span class='line'> <span class="kt">float</span> <span class="n">Q2</span> <span class="o">=</span> <span class="n">Cy</span> <span class="o">-</span> <span class="n">Ay</span><span class="p">;</span>
</span><span class='line'> <span class="kt">float</span> <span class="n">P1</span> <span class="o">=</span> <span class="n">Bx</span> <span class="o">-</span> <span class="n">Ax</span><span class="p">;</span>
</span><span class='line'> <span class="kt">float</span> <span class="n">P2</span> <span class="o">=</span> <span class="n">By</span> <span class="o">-</span> <span class="n">Ay</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="kt">float</span> <span class="n">A</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">acos</span><span class="p">(</span> <span class="p">(</span><span class="n">P1</span><span class="o">*</span><span class="n">Q1</span> <span class="o">+</span> <span class="n">P2</span><span class="o">*</span><span class="n">Q2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">P1</span><span class="o">*</span><span class="n">P1</span><span class="o">+</span><span class="n">P2</span><span class="o">*</span><span class="n">P2</span><span class="p">)</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Q1</span><span class="o">*</span><span class="n">Q1</span><span class="o">+</span><span class="n">Q2</span><span class="o">*</span><span class="n">Q2</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'> <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">CV_PI</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'> <span class="k">return</span> <span class="n">A</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">CallbackFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">userdata</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">RGB</span> <span class="o">=</span> <span class="n">frame</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">HSV</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">RGB</span><span class="p">,</span> <span class="n">HSV</span><span class="p">,</span> <span class="n">CV_BGR2HSV</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span> <span class="n">pixel</span> <span class="o">=</span> <span class="n">HSV</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">cv</span><span class="o">::</span><span class="n">EVENT_LBUTTONDBLCLK</span><span class="p">)</span> <span class="c1">// on double left clcik</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Click&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">pixel</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">pixel</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">pixel</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">minH</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span><span class='line'>            <span class="n">maxH</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span><span class='line'>            <span class="n">minS</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>            <span class="n">maxS</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>            <span class="n">minV</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'>            <span class="n">maxV</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">minH</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">minH</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;</span> <span class="n">maxH</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">maxH</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">minS</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">minS</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">maxS</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">maxS</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="n">minV</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">minV</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">maxV</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">maxV</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pixel</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">VideoCapture</span> <span class="n">cap</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">windowName</span> <span class="o">=</span> <span class="s">&quot;Fingertip detection&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">namedWindow</span><span class="p">(</span><span class="n">windowName</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">setMouseCallback</span><span class="p">(</span><span class="n">windowName</span><span class="p">,</span> <span class="n">CallbackFunc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">inAngleMin</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span> <span class="n">inAngleMax</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">angleMin</span> <span class="o">=</span> <span class="mi">180</span><span class="p">,</span> <span class="n">angleMax</span> <span class="o">=</span> <span class="mi">359</span><span class="p">,</span> <span class="n">lengthMin</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">lengthMax</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">&quot;Inner angle min&quot;</span><span class="p">,</span> <span class="n">windowName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inAngleMin</span><span class="p">,</span> <span class="mi">360</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">&quot;Inner angle max&quot;</span><span class="p">,</span> <span class="n">windowName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inAngleMax</span><span class="p">,</span> <span class="mi">360</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">&quot;Angle min&quot;</span><span class="p">,</span> <span class="n">windowName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">angleMin</span><span class="p">,</span> <span class="mi">360</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">&quot;Angle max&quot;</span><span class="p">,</span> <span class="n">windowName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">angleMax</span><span class="p">,</span> <span class="mi">360</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">&quot;Length min&quot;</span><span class="p">,</span> <span class="n">windowName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lengthMin</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">&quot;Length max&quot;</span><span class="p">,</span> <span class="n">windowName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lengthMax</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">cap</span> <span class="o">&gt;&gt;</span> <span class="n">frame</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">hsv</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">hsv</span><span class="p">,</span> <span class="n">CV_BGR2HSV</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">inRange</span><span class="p">(</span><span class="n">hsv</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="n">minH</span><span class="p">,</span> <span class="n">minS</span><span class="p">,</span> <span class="n">minV</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="n">maxH</span><span class="p">,</span> <span class="n">maxS</span><span class="p">,</span> <span class="n">maxV</span><span class="p">),</span> <span class="n">hsv</span><span class="p">);</span>
</span><span class='line'>        <span class="c1">// Pre processing</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">blurSize</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">elementSize</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">medianBlur</span><span class="p">(</span><span class="n">hsv</span><span class="p">,</span> <span class="n">hsv</span><span class="p">,</span> <span class="n">blurSize</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">element</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">getStructuringElement</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">MORPH_ELLIPSE</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">elementSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">elementSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">elementSize</span><span class="p">,</span> <span class="n">elementSize</span><span class="p">));</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">dilate</span><span class="p">(</span><span class="n">hsv</span><span class="p">,</span> <span class="n">hsv</span><span class="p">,</span> <span class="n">element</span><span class="p">);</span>
</span><span class='line'>        <span class="c1">// Contour detection</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">contours</span><span class="p">;</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec4i</span><span class="o">&gt;</span> <span class="n">hierarchy</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">findContours</span><span class="p">(</span><span class="n">hsv</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="n">hierarchy</span><span class="p">,</span> <span class="n">CV_RETR_EXTERNAL</span><span class="p">,</span> <span class="n">CV_CHAIN_APPROX_SIMPLE</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</span><span class='line'>        <span class="kt">size_t</span> <span class="n">largestContour</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">contours</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contours</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">cv</span><span class="o">::</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contours</span><span class="p">[</span><span class="n">largestContour</span><span class="p">]))</span>
</span><span class='line'>                <span class="n">largestContour</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">drawContours</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="n">largestContour</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="c1">// Convex hull</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">contours</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">hull</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="n">cv</span><span class="o">::</span><span class="n">convexHull</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">(</span><span class="n">contours</span><span class="p">[</span><span class="n">largestContour</span><span class="p">]),</span> <span class="n">hull</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">false</span><span class="p">);</span>
</span><span class='line'>            <span class="n">cv</span><span class="o">::</span><span class="n">drawContours</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">hull</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">hull</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">hullIndexes</span><span class="p">;</span>
</span><span class='line'>                <span class="n">cv</span><span class="o">::</span><span class="n">convexHull</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">(</span><span class="n">contours</span><span class="p">[</span><span class="n">largestContour</span><span class="p">]),</span> <span class="n">hullIndexes</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span><span class='line'>                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec4i</span><span class="o">&gt;</span> <span class="n">convexityDefects</span><span class="p">;</span>
</span><span class='line'>                <span class="n">cv</span><span class="o">::</span><span class="n">convexityDefects</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">(</span><span class="n">contours</span><span class="p">[</span><span class="n">largestContour</span><span class="p">]),</span> <span class="n">hullIndexes</span><span class="p">,</span> <span class="n">convexityDefects</span><span class="p">);</span>
</span><span class='line'>                <span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="n">boundingBox</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">boundingRect</span><span class="p">(</span><span class="n">hull</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>                <span class="n">cv</span><span class="o">::</span><span class="n">rectangle</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">boundingBox</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</span><span class='line'>                <span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="n">center</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">boundingBox</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">boundingBox</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">boundingBox</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">boundingBox</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">validPoints</span><span class="p">;</span>
</span><span class='line'>                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">convexityDefects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">contours</span><span class="p">[</span><span class="n">largestContour</span><span class="p">][</span><span class="n">convexityDefects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]];</span>
</span><span class='line'>                    <span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">contours</span><span class="p">[</span><span class="n">largestContour</span><span class="p">][</span><span class="n">convexityDefects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]];</span>
</span><span class='line'>                    <span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">contours</span><span class="p">[</span><span class="n">largestContour</span><span class="p">][</span><span class="n">convexityDefects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]];</span>
</span><span class='line'>                    <span class="kt">double</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atan2</span><span class="p">(</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">CV_PI</span><span class="p">;</span>
</span><span class='line'>                    <span class="kt">double</span> <span class="n">inAngle</span> <span class="o">=</span> <span class="n">innerAngle</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>                    <span class="kt">double</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
</span><span class='line'>                    <span class="k">if</span> <span class="p">(</span><span class="n">angle</span> <span class="o">&gt;</span> <span class="n">angleMin</span> <span class="o">-</span> <span class="mi">180</span> <span class="o">&amp;&amp;</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="n">angleMax</span> <span class="o">-</span> <span class="mi">180</span> <span class="o">&amp;&amp;</span> <span class="n">inAngle</span> <span class="o">&gt;</span> <span class="n">inAngleMin</span> <span class="o">-</span> <span class="mi">180</span> <span class="o">&amp;&amp;</span> <span class="n">inAngle</span> <span class="o">&lt;</span> <span class="n">inAngleMax</span> <span class="o">-</span> <span class="mi">180</span> <span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">lengthMin</span> <span class="o">/</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">boundingBox</span><span class="p">.</span><span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">lengthMax</span> <span class="o">/</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">boundingBox</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">{</span>
</span><span class='line'>                        <span class="n">validPoints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">validPoints</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="n">cv</span><span class="o">::</span><span class="n">circle</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">validPoints</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">9</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="n">windowName</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</div>


<h2>Conclusion</h2>

<p>Well&hellip; That wasn&rsquo;t so easy as it seemed at first. Detection tasks are indeed a pain in many cases. Even our example just works in very specific and unrealistic conditions (background with a much different color from our skin, hand is positioned in front of the camera in a certain angle, etc.,&hellip;), but, you know that they say: One step at a time. Until the next tutorial!</p>
]]></content>
  </entry>
  
</feed>
