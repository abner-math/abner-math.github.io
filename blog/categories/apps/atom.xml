<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Apps | Abner Araujo]]></title>
  <link href="http://abnerrjo.github.io/blog/categories/apps/atom.xml" rel="self"/>
  <link href="http://abnerrjo.github.io/"/>
  <updated>2023-01-15T23:20:14+01:00</updated>
  <id>http://abnerrjo.github.io/</id>
  <author>
    <name><![CDATA[Abner Araujo]]></name>
    <email><![CDATA[abner.rjo@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[(Python 2.7) Mesquita]]></title>
    <link href="http://abnerrjo.github.io/blog/2014/10/18/python-2-dot-7-mesquita/"/>
    <updated>2014-10-18T18:30:35-03:00</updated>
    <id>http://abnerrjo.github.io/blog/2014/10/18/python-2-dot-7-mesquita</id>
    <content type="html"><![CDATA[<p>Ahhh, and good and old (or not so old) statistics.</p>

<p>I create this software to help with my homework. In the end, just by doing it I was able to learn much more about statistical models. :)</p>

<p>Also, this software was my first attempt in create something with Python GUI, Tkinter. Wow, compared to Swing this one is like heaven!</p>

<p style="text-align:center;"><img src="/images/posts/mesquita.png" alt="" /></p>

<center><a href="https://gist.githubusercontent.com/abnerrjo/e51ffc7453acf0af3426/raw/8ce4b37a0b809c7cafdb432f961ca808d7664a60/Mesquita.py" download="Mesquita.py">Click here to download</a></center>




<!-- more -->


<p>You can see the source code below. Have fun!</p>

<center><input id="spoiler" type="button" value="See source code" onclick="toggle_visibility('code');"></center>


<div id="code">
<div><script src='https://gist.github.com/e51ffc7453acf0af3426.js?file=Mesquita.py'></script>
<noscript><pre><code>#!/usr/bin/python
# -*-coding=utf-8 -*-
#-----------------------------------------------------------------
# Mesquita v1.0
# Created by: Abner Matheus
# E-mail: abner.math.c@gmail.com
# Github: http://github.com/picoledelimao
#-----------------------------------------------------------------
import math

class MatematicaException(Exception): pass
class ProbabilidadeException(Exception): pass
class BinomialException(ProbabilidadeException): pass
class HipergeometricoException(ProbabilidadeException): pass
class GeometricoException(ProbabilidadeException): pass
class PoissonException(ProbabilidadeException): pass
class UniformeException(ProbabilidadeException): pass
class ExponencialException(ProbabilidadeException): pass
class NormalException(ProbabilidadeException): pass

class Matematica:
    #combina dois numeros inteiros, n &gt; p
    @staticmethod
    def combinacao(n, p):
        if n &lt; p or p &lt; 0 or not(isinstance(n, int) and isinstance(p, int)):
            raise MatematicaException(&quot;Parâmetros inválidos na combinação&quot;)
        n_fatorado = reduce(lambda x, y: x * y, [x for x in range(n, n-p, -1)] + [1])
        try:
            return float(n_fatorado)/math.factorial(p)
        except: return n_fatorado/math.factorial(p)

#----------------------------------------------------------------
# Modelos discretos
#----------------------------------------------------------------
class ModeloDiscreto:
    #variacao do &#39;x&#39; na reta real
    def variacao(self, x):
        raise NotImplementedError()
    #funcao de probabilidade
    def f(self):
        raise NotImplementedError()
    #funcao de probabilidade acumulada
    def F(self):
        raise NotImplementedError()
    #esperanca da v.a.
    def e(self):
        raise NotImplementedError()
    #variancia da v.a.
    def var(self):
        raise NotImplementedError()
#=================================================================
class Bernoulli(ModeloDiscreto):
    #p: chance de sucesso
    def __init__(self, p):
        try:
            self.p = float(p)
            if not 0 &lt;= self.p &lt;= 1:
                raise ProbabilidadeException(&quot;Parametro p não é uma probabilidade&quot;)
        except:
            raise ProbabilidadeException(&quot;Parametro p não é uma probabilidade&quot;)
    def fp(self):
        return self.p
    def e(self):
        return self.p
    def var(self):
        return self.p*(1-self.p)
    
class Binomial(Bernoulli):
    #n: numero de repeticoes, p: chance de sucesso
    def __init__(self, n, p):
        try:
            self.n = int(n)
        except:
            raise BinomialException(&quot;Parâmetro n deve ser um numero inteiro&quot;)
        Bernoulli.__init__(self, p)
    def variacao(self):
        return [x for x in range(0, self.n + 1)]
    def fp(self, x):
        if not x in self.variacao():
            raise BinomialException(&quot;x está fora da variação da v.a.&quot;)
        combinacao = Matematica.combinacao(self.n, x)
        chance_sucesso = math.pow(self.p, x)
        chance_fracasso = math.pow(1 - self.p, self.n - x)
        return combinacao*chance_sucesso*chance_fracasso
    def F(self, x):
        if x &lt; 0:
            return 0
        elif x &gt;= self.n:
            return 1
        count = 0
        for p in range(0, int(x)+1):
            count += self.fp(p)
        return count
    def e(self):
        return self.n*self.p
    def var(self):
        return self.n*self.p*(1-self.p)
        
class Hipergeometrico(ModeloDiscreto):
    #N: tamanho da populacao
    #n: tamanho da amostra
    #r: numero de elementos favoraveis
    def __init__(self, N, r, n):
        try:
            self.N = int(N)
            self.r = int(r)
            self.n = int(n)
            if self.N &lt; self.n or self.N &lt; self.r:
                raise HipergeometricoException(&quot;Parâmetros inválidos&quot;)
        except:
            raise HipergeometricoException(&quot;Parâmetros inválidos&quot;)
    def variacao(self):
        return [x for x in range(max(0, self.n-(self.N-self.r)), min(self.r, self.n) + 1)]
    def fp(self, x):
        if not x in self.variacao():
            raise HipergeometricoException(&quot;x está fora da variação da v.a.&quot;)
        a = Matematica.combinacao(self.r, x)
        b = Matematica.combinacao(self.N - self.r, self.n - x)
        c = Matematica.combinacao(self.N, self.n)
        return a*b/c
    def F(self, x):
        if x &lt; max(0, self.n-(self.N-self.r)):
            return 0
        elif x &gt;= min(self.r, self.n):
            return 1
        count = 0
        for p in range(max(0, self.n-(self.N-self.r)), int(x)+1):
            count += self.fp(p)
        return count
    def e(self):
        return self.n*(self.r/float(self.N))
    def var(self):
        return self.n*(self.r/float(self.N))*(1-self.r/float(self.N))*(self.N-self.n)/float(self.N-1)

class Geometrico(Bernoulli):
    #p: chance de sucesso
    def __init__(self, p):
        Bernoulli.__init__(self, p)
    def variacao(self, x):
        return isinstance(x, int) and x &gt;= 1
    def fp(self, x):
        if not self.variacao(x):
            raise GeometricoException(&quot;x está fora da variação da v.a.&quot;)
        return math.pow(1-self.p, x-1)*self.p
    def F(self, x):
        if x &lt;= 1:
            return 0
        count = 0
        for p in range(1, int(x)+1):
            count += self.fp(p)
        return count
    def e(self):
        return 1/float(self.p)
    def var(self):
        return (1-self.p)/float(math.pow(self.p, 2))

class Poisson(ModeloDiscreto):
    #alfa: media
    def __init__(self, alfa):
        try:
            self.alfa = float(alfa)
        except:
            raise PoissonException(&quot;Parâmetro inválido&quot;)
    def variacao(self, x):
        return isinstance(x, int) and x &gt;= 0
    def fp(self, x):
        if not self.variacao(x):
            raise PoissonException(&quot;x está fora da variação da v.a.&quot;)
        return math.pow(math.e, -self.alfa)*math.pow(self.alfa, x)/float(math.factorial(x))
    def F(self, x):
        if x &lt;= 0:
            return 0
        count = 0
        for p in range(0, int(x)+1):
            count += self.fp(p)
        return count
    def e(self):
        return self.alfa
    def var(self):
        return self.alfa
    

#----------------------------------------------------------------
# Modelos continuos
#----------------------------------------------------------------
class ModeloContinuo:
    #funcao distribuicao de probabilidade entre dois pontos
    def fdp(self, x, y):
        raise NotImplementedError()
    #funcao de probabilidade acumulada de -infinito ate o ponto
    def F(self, x):
        raise NotImplementedError()
    #esperanca da v.a.
    def e(self):
        raise NotImplementedError()
    #variancia da v.a.
    def var(self):
        raise NotImplementedError()
#=================================================================    
class Uniforme(ModeloContinuo):
    def __init__(self, a, b):
        try:
            self.a = float(a)
            self.b = float(b)
            if self.a &gt;= self.b:
                raise UniformeException(&quot;Parametro a é maior ou igual que o b&quot;)
        except: raise UniformeException(&quot;Parâmetros inválidos&quot;)
    def F(self, x):
        if x &lt;= self.a:
            return 0
        elif x &gt;= self.b:
            return 1
        return (x-self.a)/float(self.b-self.a)
    def fdp(self, x, y):
        if y &lt; x:
            raise UniformeException(&quot;Ponto final é menor que ponto inicial&quot;)
        return self.F(y) - self.F(x)
    def e(self):
        return (self.a + self.b)/2.0
    def var(self):
        return math.pow(self.b - self.a, 2)/12.0

class Exponencial(ModeloContinuo):
    #alfa: o inverso da media
    def __init__(self, alfa):
        try:
            self.alfa = float(alfa)
        except: raise ExponencialException(&quot;Parâmetro inválido&quot;)
        if self.alfa &lt; 0:
                raise ExponencialException(&quot;Parâmetro deve ser maior que 0&quot;)
    def F(self, x):
        if x &lt;= 0:
            return 0
        return 1 - math.pow(math.e, -self.alfa*x)
    def fdp(self, x, y):
        if y &lt; x:
            raise ExponencialException(&quot;Ponto final é menor que o ponto inicial&quot;)
        return self.F(y) - self.F(x)
    def e(self):
        return 1/float(self.alfa)
    def var(self):
        return 1/float(math.pow(self.alfa, 2))


class Normal(ModeloContinuo):
    #u: media
    #o2: variancia
    def __init__(self, u, o2):
        try:
            self.u = float(u)
            self.o2 = float(o2)
        except:
            raise NormalException(&quot;Parâmetros inválidos&quot;)
        #tabela abaixo
        self.tabela = {0.0: 0.5, 0.25: 0.5987, 2.0: 0.9772, 3.0: 0.9987, 0.5: 0.6915, 1.0: 0.8413, 3.37: 0.9996, 0.75: 0.7734, 2.83: 0.9977, 1.17: 0.879, 0.67: 0.7486, 2.28: 0.9887, 3.29: 0.9995, 3.21: 0.9993, 0.83: 0.7967, 0.6: 0.7257, 2.91: 0.9982, 3.5: 0.9998, 1.34: 0.9099, 2.25: 0.9878, 0.85: 0.8023, 3.51: 0.9998, 0.96: 0.8315, 0.66: 0.7454, 3.27: 0.9995, 0.78: 0.7823, 3.45: 0.9997, 1.67: 0.9525, 1.43: 0.9236, 2.65: 0.996, 2.03: 0.9788, 3.54: 0.9998, 2.36: 0.9909, 3.46: 0.9997, 0.14: 0.5557, 0.37: 0.6443, 1.2: 0.8849, 0.4: 0.6554, 2.62: 0.9956, 3.55: 0.9998, 2.04: 0.9793, 1.29: 0.9015, 0.46: 0.6772, 3.49: 0.9998, 0.56: 0.7123, 1.73: 0.9582, 1.51: 0.9345, 0.36: 0.6406, 3.41: 0.9997, 0.22: 0.5871, 1.09: 0.8621, 0.95: 0.8289, 0.26: 0.6026, 1.61: 0.9463, 3.24: 0.9994, 1.84: 0.9671, 2.06: 0.9803, 0.63: 0.7357, 1.81: 0.9649, 3.3: 0.9995, 1.54: 0.9382, 2.02: 0.9783, 1.95: 0.9744, 2.57: 0.9949, 2.4: 0.9918, 2.73: 0.9968, 1.9: 0.9713, 2.31: 0.9896, 0.42: 0.6628, 3.58: 0.9998, 2.52: 0.9941, 2.76: 0.9971, 2.84: 0.9977, 2.64: 0.9959, 2.17: 0.985, 2.97: 0.9985, 3.23: 0.9994, 1.94: 0.9738, 1.88: 0.9699, 3.33: 0.9996, 2.75: 0.997, 1.68: 0.9535, 2.43: 0.9925, 1.33: 0.9082, 1.85: 0.9678, 2.35: 0.9906, 2.27: 0.9884, 2.19: 0.9857, 1.77: 0.9616, 0.31: 0.6217, 1.96: 0.975, 3.14: 0.9992, 2.51: 0.994, 2.22: 0.9868, 0.73: 0.7673, 1.04: 0.8508, 1.49: 0.9319, 1.18: 0.881, 1.58: 0.9429, 1.01: 0.8438, 1.62: 0.9474, 0.1: 0.5398, 2.6: 0.9953, 1.72: 0.9573, 2.15: 0.9842, 1.76: 0.9608, 0.47: 0.6808, 1.05: 0.8531, 2.92: 0.9982, 1.1: 0.8643, 1.47: 0.9292, 3.13: 0.9991, 3.28: 0.9995, 0.09: 0.5359, 3.31: 0.9995, 0.76: 0.7764, 2.47: 0.9932, 1.63: 0.9484, 0.15: 0.5596, 3.07: 0.9989, 1.37: 0.9147, 0.7: 0.758, 2.85: 0.9978, 2.54: 0.9945, 1.23: 0.8907, 2.32: 0.9898, 0.97: 0.834, 0.74: 0.7704, 0.51: 0.695, 0.64: 0.7389, 2.55: 0.9946, 0.45: 0.6736, 2.78: 0.9973, 0.54: 0.7054, 1.44: 0.9251, 0.55: 0.7088, 0.01: 0.504, 3.39: 0.9997, 2.89: 0.9981, 2.81: 0.9975, 1.14: 0.8729, 1.8: 0.9641, 3.18: 0.9993, 1.22: 0.8888, 1.86: 0.9686, 3.16: 0.9992, 1.99: 0.9767, 3.02: 0.9987, 1.98: 0.9761, 3.26: 0.9994, 0.04: 0.516, 3.08: 0.999, 2.07: 0.9808, 0.34: 0.6331, 0.61: 0.7291, 3.11: 0.9991, 2.14: 0.9838, 3.03: 0.9988, 2.41: 0.992, 0.16: 0.5636, 0.41: 0.6591, 0.48: 0.6844, 1.36: 0.9131, 0.98: 0.8365, 3.19: 0.9993, 3.06: 0.9989, 3.43: 0.9997, 2.98: 0.9986, 3.35: 0.9996, 2.9: 0.9981, 1.5: 0.9332, 0.89: 0.8133, 1.64: 0.9495, 0.24: 0.5948, 0.52: 0.6985, 2.05: 0.9798, 1.59: 0.9441, 1.25: 0.8944, 0.3: 0.6179, 2.56: 0.9948, 2.63: 0.9957, 0.21: 0.5832, 2.71: 0.9966, 0.23: 0.591, 2.79: 0.9974, 2.12: 0.983, 0.71: 0.7611, 0.19: 0.5753, 1.87: 0.9693, 2.45: 0.9929, 1.45: 0.9265, 3.52: 0.9998, 1.89: 0.9706, 3.44: 0.9997, 3.36: 0.9996, 3.22: 0.9994, 0.07: 0.5279, 1.06: 0.8554, 3.53: 0.9998, 2.59: 0.9952, 1.53: 0.937, 3.47: 0.9997, 0.58: 0.719, 2.7: 0.9965, 3.56: 0.9998, 2.94: 0.9984, 0.28: 0.6103, 0.99: 0.8389, 1.41: 0.9207, 3.48: 0.9997, 1.7: 0.9554, 0.38: 0.648, 1.74: 0.9591, 1.78: 0.9625, 0.11: 0.5438, 1.38: 0.9162, 2.38: 0.9913, 1.92: 0.9726, 0.92: 0.8212, 1.82: 0.9656, 1.71: 0.9564, 0.35: 0.6368, 1.11: 0.8665, 0.13: 0.5517, 0.94: 0.8264, 1.12: 0.8686, 2.46: 0.9931, 1.55: 0.9394, 1.75: 0.9599, 0.68: 0.7517, 1.97: 0.9756, 0.44: 0.67, 2.68: 0.9963, 1.15: 0.8749, 2.09: 0.9817, 0.77: 0.7794, 1.28: 0.8997, 2.01: 0.9778, 0.53: 0.7019, 3.4: 0.9997, 3.57: 0.9998, 1.26: 0.8962, 2.3: 0.9893, 2.33: 0.9901, 1.31: 0.9049, 2.39: 0.9916, 0.82: 0.7939, 2.99: 0.9986, 0.84: 0.7995, 0.79: 0.7852, 0.81: 0.791, 0.59: 0.7224, 0.33: 0.6293, 2.26: 0.9881, 2.42: 0.9922, 0.86: 0.8051, 1.79: 0.9633, 1.03: 0.8485, 0.88: 0.8106, 2.34: 0.9904, 1.66: 0.9515, 0.05: 0.5199, 2.74: 0.9969, 2.21: 0.9864, 1.93: 0.9732, 2.61: 0.9955, 1.57: 0.9418, 2.2: 0.9861, 0.06: 0.5239, 3.17: 0.9992, 0.49: 0.6879, 0.2: 0.5793, 2.29: 0.989, 0.62: 0.7324, 1.13: 0.8708, 2.37: 0.9911, 2.13: 0.9834, 2.5: 0.9938, 3.2: 0.9993, 0.8: 0.7881, 1.3: 0.9032, 0.29: 0.6141, 2.48: 0.9934, 2.24: 0.9875, 2.44: 0.9927, 1.19: 0.883, 0.69: 0.7549, 0.87: 0.8078, 2.08: 0.9812, 2.82: 0.9976, 1.21: 0.8869, 2.95: 0.9984, 1.39: 0.9177, 1.91: 0.9719, 3.04: 0.9988, 3.15: 0.9992, 0.18: 0.5714, 1.52: 0.9357, 0.39: 0.6517, 0.93: 0.8238, 2.53: 0.9943, 1.24: 0.8925, 2.11: 0.9826, 2.16: 0.9846, 2.96: 0.9985, 2.49: 0.9936, 0.91: 0.8186, 2.67: 0.9962, 0.27: 0.6064, 0.72: 0.7642, 2.69: 0.9964, 2.18: 0.9854, 2.77: 0.9972, 2.87: 0.9979, 1.65: 0.9505, 2.1: 0.9821, 2.93: 0.9983, 0.65: 0.7422, 0.9: 0.8159, 1.07: 0.8577, 1.08: 0.8599, 1.32: 0.9066, 3.38: 0.9996, 3.09: 0.999, 2.8: 0.9974, 0.02: 0.508, 3.01: 0.9987, 2.23: 0.9871, 0.17: 0.5675, 0.43: 0.6664, 3.1: 0.999, 1.27: 0.898, 1.4: 0.9192, 2.66: 0.9961, 1.16: 0.877, 3.12: 0.9991, 2.58: 0.9951, 1.46: 0.9279, 0.08: 0.5319, 0.12: 0.5478, 1.69: 0.9545, 1.48: 0.9306, 1.42: 0.9222, 1.02: 0.8461, 1.56: 0.9406, 1.83: 0.9664, 3.42: 0.9997, 2.88: 0.998, 0.03: 0.512, 3.32: 0.9995, 3.25: 0.9994, 3.34: 0.9996, 3.05: 0.9989, 1.6: 0.9452, 2.86: 0.9979, 0.32: 0.6255, 1.35: 0.9115, 0.57: 0.7157, 2.72: 0.9967}
    def F(self, x):
        xNormalizada = (x - self.u)/float(math.sqrt(self.o2))
        if xNormalizada &lt; -3.5:
            return 0
        elif xNormalizada &gt; 3.5:
            return 1
        chave = float(&quot;%.2f&quot; % math.fabs(xNormalizada))
        if xNormalizada &lt; 0:
            return 1 - self.tabela[chave]
        else:
            return self.tabela[chave]
    def fdp(self, x, y):
        if y &lt; x:
            raise NormalException(&quot;Ponto final é menor que o ponto inicial&quot;)
        return self.F(y) - self.F(x)
    def e(self):
        return self.u
    def var(self):
        return self.o2

#----------------------------------------------------------------
# Interface gráfica
#----------------------------------------------------------------  
if __name__ == &#39;__main__&#39;:
    from Tkinter import *
    import tkMessageBox
    class JanelaPrincipal:
        def __init__(self, top_level):
            self.frame1 = Frame(top_level)
            self.frame1.pack(side=LEFT)
            self.frame2 = Frame(top_level)
            self.frame2.pack(side=RIGHT)
            
            width = 50
            height = 5
            Label(self.frame1, text=&quot;Modelos discretos:&quot;).pack()
            self.binomial = Button(self.frame1, text=&quot;Modelo binomial&quot;)
            self.binomial[&#39;width&#39;] = width
            self.binomial[&#39;height&#39;] = height
            self.hipergeometrico = Button(self.frame1, text=&quot;Modelo hipergeométrico&quot;)
            self.hipergeometrico[&#39;width&#39;] = width
            self.hipergeometrico[&#39;height&#39;] = height
            self.geometrico = Button(self.frame1, text=&quot;Modelo geométrico&quot;)
            self.geometrico[&#39;width&#39;] = width
            self.geometrico[&#39;height&#39;] = height
            self.poisson = Button(self.frame1, text=&quot;Modelo de Poisson&quot;)
            self.poisson[&#39;width&#39;] = width
            self.poisson[&#39;height&#39;] = height
            Label(self.frame2, text=&quot;Modelos contínuos:&quot;).pack()
            self.uniforme = Button(self.frame2, text=&quot;Modelo uniforme&quot;)
            self.uniforme[&#39;width&#39;] = width
            self.uniforme[&#39;height&#39;] = height
            self.exponencial = Button(self.frame2, text=&quot;Modelo exponencial&quot;)
            self.exponencial[&#39;width&#39;] = width
            self.exponencial[&#39;height&#39;] = height
            self.normal = Button(self.frame2, text=&quot;Modelo normal&quot;)
            self.normal[&#39;width&#39;] = width
            self.normal[&#39;height&#39;] = height
            
            self.binomial.pack()
            self.hipergeometrico.pack()
            self.geometrico.pack()
            self.poisson.pack()
            self.uniforme.pack()
            self.exponencial.pack()
            self.normal.pack()

            self.binomial.bind(&quot;&lt;Button-1&gt;&quot;, self.clica_botao)
            self.hipergeometrico.bind(&quot;&lt;Button-1&gt;&quot;, self.clica_botao)
            self.geometrico.bind(&quot;&lt;Button-1&gt;&quot;, self.clica_botao)
            self.poisson.bind(&quot;&lt;Button-1&gt;&quot;, self.clica_botao)
            self.uniforme.bind(&quot;&lt;Button-1&gt;&quot;, self.clica_botao)
            self.exponencial.bind(&quot;&lt;Button-1&gt;&quot;, self.clica_botao)
            self.normal.bind(&quot;&lt;Button-1&gt;&quot;, self.clica_botao)
        def clica_botao(self, event):
            janela = Tk()
            if event.widget == self.binomial:
                janela.title(&quot;Modelo binomial&quot;)
                JanelaBinomial(janela)
            elif event.widget == self.hipergeometrico:
                janela.title(&quot;Modelo hipergeométrico&quot;)
                JanelaHipergeometrico(janela)
            elif event.widget == self.geometrico:
                janela.title(&quot;Modelo geométrico&quot;)
                JanelaGeometrico(janela)
            elif event.widget == self.poisson:
                janela.title(&quot;Modelo de Poisson&quot;)
                JanelaPoisson(janela)
            elif event.widget == self.uniforme:
                janela.title(&quot;Modelo uniforme&quot;)
                JanelaUniforme(janela)
            elif event.widget == self.exponencial:
                janela.title(&quot;Modelo exponencial&quot;)
                JanelaExponencial(janela)
            elif event.widget == self.normal:
                janela.title(&quot;Modelo normal&quot;)
                JanelaNormal(janela)
            janela.mainloop()

    class Grafico:
        def __init__(self, raiz):
            self.width = 400
            self.height = 400
            self.canvas = Canvas(raiz, width=self.width, height=self.height)
            self.canvas.pack()
        def set_modelo(self, modelo_discreto, funcao, limiteX1, limiteX2, acumulada):
            self.modelo = modelo_discreto
            self.funcao = funcao
            self.desenha(limiteX1, limiteX2, acumulada)
            
    class GraficoDiscreto(Grafico):
        def desenha(self, limiteX1, limiteX2, acumulada):
            self.canvas.delete(&quot;all&quot;)
            try:
                variacao = self.modelo.variacao()
            except:
                if isinstance(self.modelo, Geometrico):
                    i = 1
                    while(self.modelo.F(i) &lt; 0.95):
                        i += 1
                        if i &gt; 100:
                            break
                    variacao = [x for x in range(1, i + 1)]
                elif isinstance(self.modelo, Poisson):
                    i = 0
                    while(self.modelo.F(i) &lt; 0.95):
                        i += 1
                        if i &gt; 100:
                            break
                    variacao = [x for x in range(0, i + 1)]
            variacao.insert(0, variacao[0] - 1)
            variacao.insert(0, variacao[0] - 2)
            variacao.append(variacao[-1] + 1)
            variacao.append(variacao[-1] + 2)
            #retas x e y, respectivamente
            reta_y_posicao_x = self.width/float(len(variacao)) * (math.fabs(0 - variacao[0])) + 20
            self.canvas.create_line(0, self.height - 20, self.width, self.height - 20)
            if 0 in variacao:
                self.canvas.create_line(reta_y_posicao_x, 0, reta_y_posicao_x, self.height)
            else:
                reta_y_posicao_x = 20
            #desenha os pontos
            for ponto in variacao:
                try:
                    probabilidade = self.funcao(ponto)
                    x = self.width/float(len(variacao)) * (math.fabs(ponto - variacao[0])) + 20
                    y = (self.height - 40) * probabilidade
                    if limiteX1 != None and limiteX2 != None:
                        if limiteX1 &lt;= ponto &lt;= limiteX2:
                            self.canvas.create_oval(x - 2, self.height - y - 22, x + 2, self.height - y - 18, fill=&#39;red&#39;)
                            self.canvas.create_line(x, self.height - y - 20, x, self.height - 20, fill=&#39;red&#39;)
                        else:
                            self.canvas.create_oval(x - 2, self.height - y - 22, x + 2, self.height - y - 18, fill=&#39;black&#39;)
                            self.canvas.create_line(x, self.height - y - 20, x, self.height - 20, fill=&#39;black&#39;)
                    else:
                        self.canvas.create_oval(x - 2, self.height - y - 22, x + 2, self.height - y - 18, fill=&#39;black&#39;)
                        self.canvas.create_line(x, self.height - y - 20, x, self.height - 20, fill=&#39;black&#39;)
                except: pass
            limite = 11
            if limite &gt; len(variacao):
                limite = len(variacao)
            #desenha metricas na reta x
            for i in range(1, limite):
                index = i * (len(variacao) / float(limite))
                if index != int(index):
                    index += 1
                index = int(index)
                x = self.width/float(len(variacao)) * (math.fabs(variacao[index] - variacao[0])) + 20
                self.canvas.create_text(x, self.height - 10, text=str(variacao[index]))
            #desenha metricas probabilidade
            for i in range(1, 11):
                y = self.height * i/11.0 
                self.canvas.create_text(reta_y_posicao_x - 10, self.height - y - 20, text=str(0.1 * i))

    class JanelaDiscreta:
        def __init__(self, top_level, *parametros):
            self.top_level = top_level
            self.frame_left = Frame(top_level)
            self.frame_left.pack(side=LEFT)
            self.frame_right = Frame(top_level)
            self.frame_right.pack(side=RIGHT)
            self.frame_params = {}
            self.entries = {}
            for i in range(len(parametros)):
                parametro = parametros[i]
                self.frame_params[parametro] = Frame(self.frame_left)
                self.frame_params[parametro].pack()
                Label(self.frame_params[parametro], text=parametro).pack(side=LEFT)
                self.entries[parametro] = Entry(self.frame_params[parametro])
                self.entries[parametro].pack()
            self.frame_botao_ok = Frame(self.frame_left)
            self.frame_botao_ok.pack()
            self.botao_ok = Button(self.frame_botao_ok, text=&quot;Gerar&quot;)
            self.botao_ok[&#39;width&#39;] = 30
            self.botao_ok.pack()
            self.botao_ok.bind(&quot;&lt;Button-1&gt;&quot;, self.clica_botao_ok)
            self.frame_fp = Frame(self.frame_right)
            self.frame_fp.pack(side=LEFT)
            self.frame_fda = Frame(self.frame_right)
            self.frame_fda.pack(side=LEFT)
            Label(self.frame_fp, text=&quot;Função de probabilidade:&quot;).pack()
            self.graficoFd = GraficoDiscreto(self.frame_fp)
            Label(self.frame_fda, text=&quot;Função de distribuição acumulada:&quot;).pack()
            self.graficoF = GraficoDiscreto(self.frame_fda)
            self.frame_1 = Frame(self.frame_left)
            self.frame_2 = Frame(self.frame_1)
            self.frame_2.pack()
            Label(self.frame_2, text=&quot;       P(X = x):&quot;).pack(side=LEFT)
            self.x = Entry(self.frame_2)
            self.x.pack()
            self.frame_3 = Frame(self.frame_1)
            self.frame_3.pack()
            Label(self.frame_3, text=&quot;             F(x):&quot;).pack(side=LEFT)
            self.F = Entry(self.frame_3)
            self.F.pack()
            self.frame_4 = Frame(self.frame_1)
            self.frame_4.pack()
            self.botao_calcula = Button(self.frame_4, text=&quot;Calcular&quot;)
            self.botao_calcula[&#39;width&#39;] = 30
            self.botao_calcula.pack()
            self.botao_calcula.bind(&quot;&lt;Button-1&gt;&quot;, self.clica_botao_calcula)
            self.frame_5 = Frame(self.frame_1)
            self.frame_5.pack()
            self.labelE = Label(self.frame_5, text=&quot;E(X): &quot;)
            self.labelE.pack()
            self.labelVar = Label(self.frame_5, text=&quot;Var(X): &quot;)
            self.labelVar.pack()
            self.labelP = Label(self.frame_5)
            self.labelP.pack()
            self.labelF = Label(self.frame_5)
            self.labelF.pack()
        def clica_botao_ok(self, event):
            self.graficoFd.set_modelo(self.modelo, self.modelo.fp, None, None, False)
            self.graficoF.set_modelo(self.modelo, self.modelo.F, None, None, True)
            self.frame_1.pack()
            try:
                self.labelE.setParent(None)
                self.labelVar.setParent(None)
            except: pass
            self.labelE[&#39;text&#39;] = &quot;E(X): %.5f&quot; % self.modelo.e()
            self.labelVar[&#39;text&#39;] = &quot;Var(X): %.5f&quot; % self.modelo.var()
        def clica_botao_calcula(self, event):
            try:
                x = int(self.x.get())
                try:
                    self.labelP[&#39;text&#39;] = &quot;P(X = %d) = %.5f&quot; % (x, self.modelo.fp(x))
                    self.graficoFd.set_modelo(self.modelo, self.modelo.fp, x, x, False)
                except Exception, e:
                    tkMessageBox.showwarning(&quot;Ops...&quot;, e[0], parent=self.top_level)
            except:
                if self.x.get().replace(&quot; &quot;,&quot;&quot;) != &quot;&quot;:
                    tkMessageBox.showwarning(&quot;Ops...&quot;, &quot;x deve ser um número inteiro&quot;, parent=self.top_level)
                self.graficoFd.set_modelo(self.modelo, self.modelo.fp, None, None, False)
                self.labelP[&#39;text&#39;] = &quot;&quot;
            try:
                x = float(self.F.get())
                self.labelF[&#39;text&#39;] = &quot;F(%.2f) = %.5f&quot; % (x, self.modelo.F(x))
                self.graficoF.set_modelo(self.modelo, self.modelo.F, 0, x, True)
            except:
                self.graficoF.set_modelo(self.modelo, self.modelo.F, None, None, True)
                self.labelF[&#39;text&#39;] = &quot;&quot;
        
    class JanelaBinomial(JanelaDiscreta):
        def __init__(self, top_level):
            JanelaDiscreta.__init__(self, top_level, &quot;Parâmetro n&quot;, &quot;Parâmetro p&quot;)
        def clica_botao_ok(self, event):
            n = self.entries[&quot;Parâmetro n&quot;].get()
            p = self.entries[&quot;Parâmetro p&quot;].get()
            try:
                self.modelo = Binomial(n, p)
                JanelaDiscreta.clica_botao_ok(self, event)
            except Exception, e:
                tkMessageBox.showwarning(&quot;Ops...&quot;, e[0], parent=self.top_level)

    class JanelaHipergeometrico(JanelaDiscreta):
        def __init__(self, top_level):
            JanelaDiscreta.__init__(self, top_level, &quot;Parâmetro N&quot;, &quot;Parâmetro r&quot;, &quot;Parâmetro n&quot;)
        def clica_botao_ok(self, event):
            N = self.entries[&quot;Parâmetro N&quot;].get()
            r = self.entries[&quot;Parâmetro r&quot;].get()
            n = self.entries[&quot;Parâmetro n&quot;].get()
            try:
                self.modelo = Hipergeometrico(N, r, n)
                JanelaDiscreta.clica_botao_ok(self, event)
            except Exception, e:
                tkMessageBox.showwarning(&quot;Ops...&quot;, e[0], parent=self.top_level)

    class JanelaGeometrico(JanelaDiscreta):
        def __init__(self, top_level):
            JanelaDiscreta.__init__(self, top_level, &quot;Parâmetro p&quot;)
        def clica_botao_ok(self, event):
            p = self.entries[&quot;Parâmetro p&quot;].get()
            try:
                self.modelo = Geometrico(p)
                JanelaDiscreta.clica_botao_ok(self, event)
            except Exception, e:
                tkMessageBox.showwarning(&quot;Ops...&quot;, e[0], parent=self.top_level)

    class JanelaPoisson(JanelaDiscreta):
        def __init__(self, top_level):
            JanelaDiscreta.__init__(self, top_level, &quot;Parâmetro gama&quot;)
        def clica_botao_ok(self, event):
            alfa = self.entries[&quot;Parâmetro gama&quot;].get()
            try:
                self.modelo = Poisson(alfa)
                JanelaDiscreta.clica_botao_ok(self, event)
            except Exception, e:
                tkMessageBox.showwarning(&quot;Ops...&quot;, e[0], parent=self.top_level)


    class GraficoContinuo(Grafico):
        def desenha(self, limiteX1, limiteX2, acumulada):
            self.canvas.delete(&quot;all&quot;)
            if isinstance(self.modelo, Uniforme):
                a = self.modelo.a
                b = self.modelo.b + 1
            elif isinstance(self.modelo, Exponencial):
                a = -1
                b = 0
                while self.modelo.F(b) &lt; 0.995:
                    b += 1
                    if b &gt; 100:
                        break
            elif isinstance(self.modelo, Normal):
                a = 0
                while self.modelo.F(a) &gt; 0:
                    a -= 1
                b = 0
                while self.modelo.F(b) &lt; 1:
                    b += 1
            l = math.fabs(b-a)/1000.0 
            tamanho = math.fabs(b-a) 
            variacao = [x*l+a for x in range(0, 1000)]
            #retas x e y, respectivamente
            reta_y_posicao_x = self.width/float(tamanho) * (math.fabs(0 - variacao[0])) + 20
            self.canvas.create_line(0, self.height - 20, self.width, self.height - 20)
            if variacao[0] &lt;= 0 &lt;= variacao[-1]:
                self.canvas.create_line(reta_y_posicao_x, 0, reta_y_posicao_x, self.height)
            else:
                reta_y_posicao_x = 20
            #desenha os pontos
            for indice, ponto in enumerate(variacao):
                try:
                    if acumulada:
                        probabilidade = self.funcao(ponto)
                    else:
                        probabilidade = self.funcao(variacao[indice], variacao[indice+1]) * 100
                    x = self.width/float(tamanho) * (math.fabs(ponto - variacao[0])) + 20
                    y = (self.height - 40) * probabilidade
                    if limiteX1 != None and limiteX2 != None:
                        if limiteX1 &lt;= ponto &lt;= limiteX2:
                            self.canvas.create_line(x, self.height - y - 20, x + 1, self.height - y - 20, fill=&#39;red&#39;)
                            self.canvas.create_line(x, self.height - y - 20, x, self.height - 20, fill=&#39;red&#39;)
                        else:
                            self.canvas.create_line(x, self.height - y - 20, x + 1, self.height - y - 20, fill=&#39;black&#39;)
                            self.canvas.create_line(x, self.height - y - 20, x, self.height - 20, fill=&#39;black&#39;)
                    else:
                        self.canvas.create_line(x, self.height - y - 20, x + 1, self.height - y - 20, fill=&#39;black&#39;)
                        self.canvas.create_line(x, self.height - y - 20, x, self.height - 20, fill=&#39;black&#39;)
                except: pass
            limite = 11
            #desenha metricas na reta x
            for i in range(1, limite):
                index = i * len(variacao) / float(limite)
                index = int(index) 
                tamanhoInicial = math.fabs(variacao[index] - variacao[0])
                tamanhoTotal = math.fabs(variacao[-1] - variacao[0])
                factor = tamanhoInicial / float(tamanhoTotal) 
                x = self.width * factor + 20
                self.canvas.create_text(x, self.height - 10, text=str(variacao[index]))
            #desenha metricas probabilidade
            for i in range(1, 11):
                y = self.height * i/11.0 
                self.canvas.create_text(reta_y_posicao_x - 10, self.height - y - 20, text=str(0.1 * i))

        def desenha22(self, limiteX1, limiteX2, acumulada):
            self.canvas.delete(&quot;all&quot;)
            if isinstance(self.modelo, Uniforme):
                variacao = [x for x in range(int(self.modelo.a * 100), int((self.modelo.b + 1) * 100 ))]
            elif isinstance(self.modelo, Exponencial):
                variacao = [x for x in range(0, 10 * 100)]
            elif isinstance(self.modelo, Normal):
                inflexao = 3.5 * self.modelo.o2 + self.modelo.u
                inicial = (self.modelo.u - inflexao) * 100
                final = (self.modelo.u + inflexao) * 100
                variacao = [x for x in range(int(inicial), int(final))]
            #retas x e y, respectivamente
            reta_y_posicao_x = (self.width - 20)/float(len(variacao)) * (math.fabs(0 - variacao[0])) + 40
            self.canvas.create_line(0, self.height - 20, self.width, self.height - 20)
            self.canvas.create_line(reta_y_posicao_x, 0, reta_y_posicao_x, self.height)
            #desenha os pontos
            for ponto in variacao:
                if acumulada:
                    probabilidade = self.funcao(ponto/100.0)
                else:
                    probabilidade = self.funcao(ponto/100.0, ponto/100.0 + 1)
                x = (self.width+40)/float(len(variacao)) * (math.fabs(ponto - variacao[0])) + 40
                y = (self.height - 30) * probabilidade
                if limiteX1 != None and limiteX2 != None:
                    if limiteX1 &lt;= ponto/100.0 + 0.5 &lt;= limiteX2:
                        self.canvas.create_line(x, self.height - y - 20, x + 1, self.height - 20, fill=&#39;red&#39;)
                    else:
                        self.canvas.create_line(x, self.height - y - 20, x + 1, self.height - 20, fill=&#39;black&#39;)
                else:
                    self.canvas.create_line(x, self.height - y - 20, x + 1, self.height - 20, fill=&#39;black&#39;)
            limite = 11
            if limite &gt; len(variacao):
                limite = len(variacao)
            #desenha metricas na reta x
            for i in range(1, limite):
                index = i * (len(variacao) / float(limite))
                if index != int(index):
                    index += 1
                index = int(index)
                x = (self.width - 20)/float(len(variacao)) * (math.fabs(variacao[index] - variacao[0])) + 40
                self.canvas.create_text(x, self.height - 10, text=&quot;%.2f&quot; % (variacao[index]/100.0))
            #desenha metricas probabilidade
            for i in range(1, 11):
                y = self.height / 11.0 * i 
                self.canvas.create_text(reta_y_posicao_x - 20, self.height - y - 10, text=str(0.1 * i))

    class JanelaContinua:
        def __init__(self, top_level, *parametros):
            self.top_level = top_level
            self.frame_left = Frame(top_level)
            self.frame_left.pack(side=LEFT)
            self.frame_right = Frame(top_level)
            self.frame_right.pack(side=RIGHT)
            self.frame_params = {}
            self.entries = {}
            for i in range(len(parametros)):
                parametro = parametros[i]
                self.frame_params[parametro] = Frame(self.frame_left)
                self.frame_params[parametro].pack()
                Label(self.frame_params[parametro], text=&quot;        &quot; +parametro).pack(side=LEFT)
                self.entries[parametro] = Entry(self.frame_params[parametro])
                self.entries[parametro].pack()
            self.frame_botao_ok = Frame(self.frame_left)
            self.frame_botao_ok.pack()
            self.botao_ok = Button(self.frame_botao_ok, text=&quot;Gerar&quot;)
            self.botao_ok[&#39;width&#39;] = 35
            self.botao_ok.pack()
            self.botao_ok.bind(&quot;&lt;Button-1&gt;&quot;, self.clica_botao_ok)
            self.frame_fp = Frame(self.frame_right)
            self.frame_fp.pack(side=LEFT)
            self.frame_fda = Frame(self.frame_right)
            self.frame_fda.pack(side=LEFT)
            Label(self.frame_fp, text=&quot;Função distribuição de probabilidade:&quot;).pack()
            self.graficoFd = GraficoContinuo(self.frame_fp)
            Label(self.frame_fda, text=&quot;Função de distribuição acumulada:&quot;).pack()
            self.graficoF = GraficoContinuo(self.frame_fda)
            self.frame_1 = Frame(self.frame_left)
            self.frame_2 = Frame(self.frame_1)
            self.frame_2.pack()
            Label(self.frame_2, text=&quot;P(a &lt;= x &lt;= b):&quot;).pack(side=LEFT)
            self.x1 = Entry(self.frame_2)
            self.x1.pack()
            self.x2 = Entry(self.frame_2)
            self.x2.pack(side=RIGHT)
            self.frame_3 = Frame(self.frame_1)
            self.frame_3.pack()
            Label(self.frame_3, text=&quot;                  F(x):&quot;).pack(side=LEFT)
            self.F = Entry(self.frame_3)
            self.F.pack()
            self.frame_4 = Frame(self.frame_1)
            self.frame_4.pack()
            self.botao_calcula = Button(self.frame_4, text=&quot;Calcular&quot;)
            self.botao_calcula[&#39;width&#39;] = 35
            self.botao_calcula.pack()
            self.botao_calcula.bind(&quot;&lt;Button-1&gt;&quot;, self.clica_botao_calcula)
            self.frame_5 = Frame(self.frame_1)
            self.frame_5.pack()
            self.labelE = Label(self.frame_5, text=&quot;E(X): &quot;)
            self.labelE.pack()
            self.labelVar = Label(self.frame_5, text=&quot;Var(X): &quot;)
            self.labelVar.pack()
            self.labelP = Label(self.frame_5)
            self.labelP.pack()
            self.labelF = Label(self.frame_5)
            self.labelF.pack()
        def clica_botao_ok(self, event):
            self.graficoFd.set_modelo(self.modelo, self.modelo.fdp, None, None, False)
            self.graficoF.set_modelo(self.modelo, self.modelo.F, None, None, True)
            self.frame_1.pack()
            try:
                self.labelE.setParent(None)
                self.labelVar.setParent(None)
            except: pass
            self.labelE[&#39;text&#39;] = &quot;E(X): %.5f&quot; % self.modelo.e()
            self.labelVar[&#39;text&#39;] = &quot;Var(X): %.5f&quot; % self.modelo.var()
        def clica_botao_calcula(self, event):
            try:
                x = float(self.x1.get())
                y = float(self.x2.get())
                try:
                    self.labelP[&#39;text&#39;] = &quot;P(%.2f &lt;= X &lt;= %.2f) = %.5f&quot; % (x, y, self.modelo.fdp(x, y))
                    self.graficoFd.set_modelo(self.modelo, self.modelo.fdp, x, y, False)
                except Exception, e:
                    tkMessageBox.showwarning(&quot;Ops...&quot;, e[0], parent=self.top_level)
            except:
                if self.x1.get().replace(&quot; &quot;,&quot;&quot;) != &quot;&quot; or self.x2.get().replace(&quot; &quot;,&quot;&quot;) != &quot;&quot;:
                    tkMessageBox.showwarning(&quot;Ops...&quot;, &quot;x deve ser um número inteiro&quot;, parent=self.top_level)
                self.graficoFd.set_modelo(self.modelo, self.modelo.fdp, None, None, False)
                self.labelP[&#39;text&#39;] = &quot;&quot;
            try:
                x = float(self.F.get())
                self.labelF[&#39;text&#39;] = &quot;F(%.2f) = %.5f&quot; % (x, self.modelo.F(x))
                self.graficoF.set_modelo(self.modelo, self.modelo.F, -9999999999999, x, True)
            except:
                self.graficoF.set_modelo(self.modelo, self.modelo.F, None, None, True)
                self.labelF[&#39;text&#39;] = &quot;&quot;
        
    class JanelaUniforme(JanelaContinua):
        def __init__(self, top_level):
            JanelaContinua.__init__(self, top_level, &quot;Parâmetro a&quot;, &quot;Parâmetro b&quot;)
        def clica_botao_ok(self, event):
            a = self.entries[&quot;Parâmetro a&quot;].get()
            b = self.entries[&quot;Parâmetro b&quot;].get()
            try:
                self.modelo = Uniforme(a, b)
                JanelaContinua.clica_botao_ok(self, event)
            except Exception, e:
                tkMessageBox.showwarning(&quot;Ops...&quot;, e[0], parent=self.top_level)
                
    class JanelaExponencial(JanelaContinua):
        def __init__(self, top_level):
            JanelaContinua.__init__(self, top_level, &quot;Parâmetro alfa&quot;)
        def clica_botao_ok(self, event):
            a = self.entries[&quot;Parâmetro alfa&quot;].get()
            try:
                self.modelo = Exponencial(a)
                JanelaContinua.clica_botao_ok(self, event)
            except Exception, e:
                tkMessageBox.showwarning(&quot;Ops...&quot;, e[0], parent=self.top_level)

    class JanelaNormal(JanelaContinua):
        def __init__(self, top_level):
            JanelaContinua.__init__(self, top_level, &quot;Média&quot;, &quot;Variância&quot;)
        def clica_botao_ok(self, event):
            u = self.entries[&quot;Média&quot;].get()
            o2 = self.entries[&quot;Variância&quot;].get()
            try:
                self.modelo = Normal(u, o2)
                JanelaContinua.clica_botao_ok(self, event)
            except Exception, e: 
                tkMessageBox.showwarning(&quot;Ops...&quot;, e[0], parent=self.top_level)
                
    raiz = Tk()
    raiz.title(&quot;Mesquita 1.0&quot;)
    JanelaPrincipal(raiz)
    raiz.mainloop()
</code></pre></noscript></div>

</div>


<p></input></p>
]]></content>
  </entry>
  
</feed>
